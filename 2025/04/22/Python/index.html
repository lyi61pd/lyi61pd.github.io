<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python | lyi61pd</title><meta name="author" content="lyi61pd"><meta name="copyright" content="lyi61pd"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="引用与非引用类型Python中的引用类型与非引用类型在Python中，数据类型可以分为引用类型（可变类型）和非引用类型（不可变类型）。它们在内存中的存储方式和函数传参时的行为有明显的区别。 引用类型与非引用类型引用类型（可变类型）引用类型是指那些在内存中可以被修改的对象。常见的引用类型包括：  列表（List） 字典（Dict） 集合（Set）  这些类型的对象在创建后，其内容是可以修改的。对于这">
<meta property="og:type" content="article">
<meta property="og:title" content="Python">
<meta property="og:url" content="https://lyi61pd.github.io/2025/04/22/Python/">
<meta property="og:site_name" content="lyi61pd">
<meta property="og:description" content="引用与非引用类型Python中的引用类型与非引用类型在Python中，数据类型可以分为引用类型（可变类型）和非引用类型（不可变类型）。它们在内存中的存储方式和函数传参时的行为有明显的区别。 引用类型与非引用类型引用类型（可变类型）引用类型是指那些在内存中可以被修改的对象。常见的引用类型包括：  列表（List） 字典（Dict） 集合（Set）  这些类型的对象在创建后，其内容是可以修改的。对于这">
<meta property="og:locale">
<meta property="og:image" content="https://lyi61pd.github.io/blog_imgs/avatar.png">
<meta property="article:published_time" content="2025-04-22T00:00:00.000Z">
<meta property="article:modified_time" content="2025-07-30T03:40:55.100Z">
<meta property="article:author" content="lyi61pd">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lyi61pd.github.io/blog_imgs/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python",
  "url": "https://lyi61pd.github.io/2025/04/22/Python/",
  "image": "https://lyi61pd.github.io/blog_imgs/avatar.png",
  "datePublished": "2025-04-22T00:00:00.000Z",
  "dateModified": "2025-07-30T03:40:55.100Z",
  "author": [
    {
      "@type": "Person",
      "name": "lyi61pd",
      "url": "https://lyi61pd.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/blog_imgs/avatar.png"><link rel="canonical" href="https://lyi61pd.github.io/2025/04/22/Python/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="lyi61pd" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/blog_imgs/banner.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">lyi61pd</span></a><a class="nav-page-title" href="/"><span class="site-name">Python</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div></div></nav><div id="post-info"><h1 class="post-title">Python</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-04-22T00:00:00.000Z" title="Created 2025-04-22 00:00:00">2025-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-30T03:40:55.100Z" title="Updated 2025-07-30 03:40:55">2025-07-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="引用与非引用类型"><a href="#引用与非引用类型" class="headerlink" title="引用与非引用类型"></a>引用与非引用类型</h1><h2 id="Python中的引用类型与非引用类型"><a href="#Python中的引用类型与非引用类型" class="headerlink" title="Python中的引用类型与非引用类型"></a>Python中的引用类型与非引用类型</h2><p>在Python中，数据类型可以分为引用类型（可变类型）和非引用类型（不可变类型）。它们在内存中的存储方式和函数传参时的行为有明显的区别。</p>
<h2 id="引用类型与非引用类型"><a href="#引用类型与非引用类型" class="headerlink" title="引用类型与非引用类型"></a>引用类型与非引用类型</h2><h3 id="引用类型（可变类型）"><a href="#引用类型（可变类型）" class="headerlink" title="引用类型（可变类型）"></a>引用类型（可变类型）</h3><p>引用类型是指那些在内存中可以被修改的对象。常见的引用类型包括：</p>
<ul>
<li><strong>列表（List）</strong></li>
<li><strong>字典（Dict）</strong></li>
<li><strong>集合（Set）</strong></li>
</ul>
<p>这些类型的对象在创建后，其内容是可以修改的。对于这些类型的数据，当它们作为函数参数传递时，实际上传递的是对象的<strong>引用</strong>（即内存地址）。因此，在函数内对该对象进行修改时，原始对象的内容会发生变化。</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_list</span>(<span class="params">my_list</span>):</span><br><span class="line">    my_list.append(<span class="number">4</span>)  <span class="comment"># 修改传入的列表</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">modify_list(lst)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># 输出：[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，传入<code>modify_list</code>函数的是列表<code>lst</code>的引用，因此在函数内部对<code>lst</code>进行修改时，原始的<code>lst</code>也发生了变化。</p>
<h3 id="非引用类型（不可变类型）"><a href="#非引用类型（不可变类型）" class="headerlink" title="非引用类型（不可变类型）"></a>非引用类型（不可变类型）</h3><p>非引用类型是指那些不能在内存中被修改的对象。常见的不可变类型包括：</p>
<ul>
<li><strong>整数（int）</strong></li>
<li><strong>浮点数（float）</strong></li>
<li><strong>字符串（str）</strong></li>
<li><strong>元组（tuple）</strong></li>
</ul>
<p>这些类型的对象一旦创建，其值不可更改。当它们作为函数参数传递时，传递的是该对象的<strong>副本</strong>。即使在函数内修改参数，原始对象的值也不会发生变化，因为不可变对象无法被修改，任何修改都会创建一个新的对象。</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_integer</span>(<span class="params">x</span>):</span><br><span class="line">    x += <span class="number">1</span>  <span class="comment"># 修改传入的整数</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">modify_integer(a)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出：5</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>a</code>的值传递给<code>modify_integer</code>函数时，实际上是传递了<code>a</code>的值副本（5）。在函数内部，<code>x</code>的值发生变化，但<code>a</code>本身没有受到影响。</p>
<h2 id="函数传参与引用类型、非引用类型的关系"><a href="#函数传参与引用类型、非引用类型的关系" class="headerlink" title="函数传参与引用类型、非引用类型的关系"></a>函数传参与引用类型、非引用类型的关系</h2><h3 id="引用类型传参"><a href="#引用类型传参" class="headerlink" title="引用类型传参"></a>引用类型传参</h3><p>对于引用类型（如列表、字典等），函数接收到的是对象的引用。这意味着，函数内部修改了该对象，原始对象也会受到影响。</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_dict</span>(<span class="params">d</span>):</span><br><span class="line">    d[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;new_value&quot;</span>  <span class="comment"># 修改传入的字典</span></span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;old_value&quot;</span>&#125;</span><br><span class="line">modify_dict(data)</span><br><span class="line"><span class="built_in">print</span>(data)  <span class="comment"># 输出：&#123;&#x27;key&#x27;: &#x27;new_value&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，字典<code>data</code>作为参数传入<code>modify_dict</code>函数。因为字典是可变的，所以修改字典的内容会影响到原始字典<code>data</code>。</p>
<h3 id="非引用类型传参"><a href="#非引用类型传参" class="headerlink" title="非引用类型传参"></a>非引用类型传参</h3><p>对于不可变类型（如整数、字符串、元组等），函数接收到的是对象的值副本。尽管函数内部对该对象进行了修改，但这并不会改变原始对象的值。原因在于这些对象是不可变的，修改操作会创建新的对象。</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_string</span>(<span class="params">s</span>):</span><br><span class="line">    s += <span class="string">&quot; world&quot;</span>  <span class="comment"># 创建了新的字符串对象</span></span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">modify_string(str1)</span><br><span class="line"><span class="built_in">print</span>(str1)  <span class="comment"># 输出：hello</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>str1</code>作为参数传入<code>modify_string</code>函数。由于字符串是不可变的，<code>s += &quot; world&quot;</code>会创建一个新的字符串对象，<code>str1</code>保持不变。</p>
<hr>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>在Python中，类是创建对象的模板。类定义了对象的属性和方法，通过类可以创建多个对象，每个对象都有自己的属性和方法。理解类的基本概念是学习面向对象编程的第一步。</p>
<h2 id="Python中的类与对象"><a href="#Python中的类与对象" class="headerlink" title="Python中的类与对象"></a>Python中的类与对象</h2><p>Python是一种面向对象的编程语言，其中类是面向对象编程的核心。类是创建对象的模板，而对象则是类的实例。理解类与对象是学习Python的重要基础。</p>
<h3 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h3><p>在Python中，类是通过<code>class</code>关键字来定义的。类包含了属性（也叫成员变量）和方法（也叫成员函数）。类的定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    species = <span class="string">&quot;Canis familiaris&quot;</span>  <span class="comment"># 所有Dog对象共享的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化方法，用于初始化对象的属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name  <span class="comment"># 实例属性</span></span><br><span class="line">        <span class="variable language_">self</span>.age = age  <span class="comment"># 实例属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法：类的行为</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> says Woof!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>Dog</code>类有：</p>
<ul>
<li>一个类属性<code>species</code>，所有<code>Dog</code>对象共享这个属性。</li>
<li>两个实例属性<code>name</code>和<code>age</code>，每个对象都有独立的属性。</li>
<li>一个方法<code>bark</code>，表示狗叫的动作。</li>
</ul>
<h3 id="创建类的实例（对象）"><a href="#创建类的实例（对象）" class="headerlink" title="创建类的实例（对象）"></a>创建类的实例（对象）</h3><p>类定义好后，可以使用类来创建对象。通过调用类名并传入所需的参数来创建对象，每个对象都有自己独立的属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Dog类的实例</span></span><br><span class="line">dog1 = Dog(<span class="string">&quot;Buddy&quot;</span>, <span class="number">3</span>)</span><br><span class="line">dog2 = Dog(<span class="string">&quot;Lucy&quot;</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问对象的属性</span></span><br><span class="line"><span class="built_in">print</span>(dog1.name)  <span class="comment"># 输出：Buddy</span></span><br><span class="line"><span class="built_in">print</span>(dog2.age)   <span class="comment"># 输出：5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用对象的方法</span></span><br><span class="line">dog1.bark()  <span class="comment"># 输出：Buddy says Woof!</span></span><br><span class="line">dog2.bark()  <span class="comment"># 输出：Lucy says Woof!</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>dog1</code>和<code>dog2</code>是<code>Dog</code>类的实例，它们各自拥有不同的<code>name</code>和<code>age</code>属性。通过调用<code>bark()</code>方法，它们分别发出不同的叫声。</p>
<h2 id="init-方法与构造函数"><a href="#init-方法与构造函数" class="headerlink" title="__init__方法与构造函数"></a><code>__init__</code>方法与构造函数</h2><h3 id="init-方法"><a href="#init-方法" class="headerlink" title="__init__方法"></a><code>__init__</code>方法</h3><p>在Python中，<code>__init__</code>方法是类的构造函数。当创建类的实例时，<code>__init__</code>方法会自动调用。它用于初始化新创建对象的属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, color</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.color = color</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meow</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> says Meow!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Cat对象</span></span><br><span class="line">cat = Cat(<span class="string">&quot;Whiskers&quot;</span>, <span class="string">&quot;black&quot;</span>)</span><br><span class="line">cat.meow()  <span class="comment"># 输出：Whiskers says Meow!</span></span><br></pre></td></tr></table></figure>

<h3 id="self参数"><a href="#self参数" class="headerlink" title="self参数"></a><code>self</code>参数</h3><p><code>__init__</code>方法中的第一个参数是<code>self</code>，它代表类的实例本身。当创建对象时，<code>self</code>会指向当前对象。每个方法都必须包含<code>self</code>参数，以便访问类的属性和方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name  <span class="comment"># self指向当前实例对象</span></span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is <span class="subst">&#123;self.age&#125;</span> years old.&quot;</span>)</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">&quot;Buddy&quot;</span>, <span class="number">3</span>)</span><br><span class="line">dog.display_info()  <span class="comment"># 输出：Buddy is 3 years old.</span></span><br></pre></td></tr></table></figure>

<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>继承是面向对象编程中的重要概念，它允许一个类继承另一个类的属性和方法。在Python中，子类继承父类时，可以重用父类的方法，也可以扩展或重写父类的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, species</span>):</span><br><span class="line">        <span class="variable language_">self</span>.species = species</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.species&#125;</span> makes a sound&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&quot;Dog&quot;</span>)  <span class="comment"># 调用父类的构造函数</span></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> says Woof!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Dog对象</span></span><br><span class="line">dog = Dog(<span class="string">&quot;Buddy&quot;</span>, <span class="number">3</span>)</span><br><span class="line">dog.speak()  <span class="comment"># 输出：Buddy says Woof!</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Dog</code>类继承了<code>Animal</code>类，并重写了<code>speak</code>方法。通过<code>super()</code>函数调用父类的构造函数，从而初始化<code>Animal</code>类的属性。</p>
<h2 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h2><p>多态是指同一个方法在不同类的对象上有不同的表现。在Python中，方法的多态性通常是通过继承和方法重写实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&quot;Cat&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> says Meow!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建不同的对象</span></span><br><span class="line">dog = Dog(<span class="string">&quot;Buddy&quot;</span>, <span class="number">3</span>)</span><br><span class="line">cat = Cat(<span class="string">&quot;Whiskers&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用相同的方法，但不同的表现</span></span><br><span class="line">dog.speak()  <span class="comment"># 输出：Buddy says Woof!</span></span><br><span class="line">cat.speak()  <span class="comment"># 输出：Whiskers says Meow!</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>dog.speak()</code>和<code>cat.speak()</code>调用了相同的方法名，但由于它们分别属于<code>Dog</code>和<code>Cat</code>类，所以方法的实现不同，表现出了多态。</p>
<h2 id="类的私有属性与方法"><a href="#类的私有属性与方法" class="headerlink" title="类的私有属性与方法"></a>类的私有属性与方法</h2><p>在Python中，类的属性和方法默认是公有的，可以在外部访问和修改。如果希望某些属性或方法不被外部直接访问，可以通过在属性或方法名前加上双下划线（<code>__</code>）来将它们设为私有。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="variable language_">self</span>.make = make</span><br><span class="line">        <span class="variable language_">self</span>.model = model</span><br><span class="line">        <span class="variable language_">self</span>.__year = year  <span class="comment"># 私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_year</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__year  <span class="comment"># 通过公共方法访问私有属性</span></span><br><span class="line"></span><br><span class="line">car = Car(<span class="string">&quot;Toyota&quot;</span>, <span class="string">&quot;Corolla&quot;</span>, <span class="number">2020</span>)</span><br><span class="line"><span class="built_in">print</span>(car.make)  <span class="comment"># 输出：Toyota</span></span><br><span class="line"><span class="built_in">print</span>(car.get_year())  <span class="comment"># 输出：2020</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下将抛出错误，因为__year是私有的</span></span><br><span class="line"><span class="comment"># print(car.__year)  # 报错：AttributeError</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>__year</code>是<code>Car</code>类的私有属性，不能被外部直接访问。通过<code>get_year</code>方法，外部可以间接访问该属性。</p>
<h2 id="访问实例的属性的调用顺序"><a href="#访问实例的属性的调用顺序" class="headerlink" title="访问实例的属性的调用顺序"></a>访问实例的属性的调用顺序</h2><ul>
<li>当类属性和实例属性重名时，优先会返回实例属性</li>
<li>给实例对象的属性赋值时，赋值的是实例属性，如果没有对应实例属性就会新建</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    test=<span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v1</span>):</span><br><span class="line">        <span class="variable language_">self</span>.v1 = v1</span><br><span class="line"></span><br><span class="line">car1 = Car(<span class="string">&quot;aa&quot;</span>)</span><br><span class="line">car2 = Car(<span class="string">&quot;bb&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(car1.test) <span class="comment"># 1</span></span><br><span class="line">Car.test = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(Car.test) <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(car1.test) <span class="comment"># 2 这里访问的是car1的类属性</span></span><br><span class="line">car1.test = <span class="number">3</span> <span class="comment"># 这里car1新建了实例属性test，和类属性重名，后续访问car1.test就会优先访问实例属性</span></span><br><span class="line"><span class="built_in">print</span>(car1.test) <span class="comment"># 3 这里访问的是car1的实例属性</span></span><br><span class="line"><span class="built_in">print</span>(Car.test) <span class="comment"># 2 类属性没有变化</span></span><br><span class="line"><span class="keyword">del</span> car1.test <span class="comment"># 如果删除car1的实例属性</span></span><br><span class="line"><span class="built_in">print</span>(car1.test) <span class="comment"># 2 car1的类属性就显示了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>类的定义</strong>：通过<code>class</code>关键字定义类，类包含属性和方法。</li>
<li><strong>实例化对象</strong>：通过类创建对象，每个对象有自己独立的属性。</li>
<li><code>**__init__**</code><strong>方法</strong>：初始化对象的属性，是构造函数。</li>
<li><strong>继承</strong>：子类可以继承父类的属性和方法，重写或扩展父类的方法。</li>
<li><strong>多态</strong>：相同方法在不同类的对象上有不同的表现。</li>
<li><strong>私有属性和方法</strong>：通过双下划线（<code>__</code>）将属性和方法设为私有，避免外部直接访问。</li>
</ul>
<hr>
<h1 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h1><h2 id="Python中的拷贝"><a href="#Python中的拷贝" class="headerlink" title="Python中的拷贝"></a>Python中的拷贝</h2><p>在Python中，拷贝指的是复制一个对象的过程。拷贝操作常用于需要对对象进行修改时，避免直接修改原始对象。Python中有两种主要的拷贝方式：<strong>浅拷贝</strong>和<strong>深拷贝</strong>。理解这两种拷贝方式的区别对于编写高效、可靠的代码非常重要。</p>
<h3 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h3><p>浅拷贝是指创建一个新对象，但该对象的元素是原始对象中元素的引用（即内存地址）。这意味着，浅拷贝后的新对象与原始对象共享相同的元素。如果新对象的元素本身是可变的，修改这些元素会影响到原始对象。</p>
<p>浅拷贝可以通过<code>copy</code>模块中的<code>copy()</code>方法或对象的<code>copy()</code>方法来实现。</p>
<p><strong>浅拷贝示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含列表的字典</span></span><br><span class="line">original_dict = &#123;<span class="string">&quot;test&quot;</span>:<span class="number">1</span>,<span class="string">&quot;numbers&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&quot;letters&quot;</span>: [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用copy方法进行浅拷贝</span></span><br><span class="line">shallow_copy_dict = copy.copy(original_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改新字典中的元素</span></span><br><span class="line">shallow_copy_dict[<span class="string">&quot;numbers&quot;</span>].append(<span class="number">4</span>)</span><br><span class="line">shallow_copy_dict[<span class="string">&quot;test&quot;</span>]=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Original:&quot;</span>, original_dict)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Shallow Copy:&quot;</span>, shallow_copy_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Original: &#123;&#x27;test&#x27;: 1, &#x27;numbers&#x27;: [1, 2, 3, 4], &#x27;letters&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&#125;</span></span><br><span class="line"><span class="comment"># Shallow Copy: &#123;&#x27;test&#x27;: 2, &#x27;numbers&#x27;: [1, 2, 3, 4], &#x27;letters&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>shallow_copy_dict</code>是<code>original_dict</code>的浅拷贝。虽然字典对象本身是被复制的，但其中的<code>numbers</code>和<code>letters</code>列表依然是共享的，因此对<code>numbers</code>列表的修改会影响到<code>original_dict</code>。</p>
<h3 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h3><p>深拷贝会创建一个新的对象，并递归地复制原始对象中的所有元素，包括嵌套的对象。深拷贝后的新对象与原始对象完全独立，任何对新对象的修改都不会影响原始对象。</p>
<p>深拷贝可以通过<code>copy</code>模块中的<code>deepcopy()</code>方法来实现。</p>
<p><strong>深拷贝示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含列表的字典</span></span><br><span class="line">original_dict = &#123;<span class="string">&quot;numbers&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&quot;letters&quot;</span>: [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用deepcopy方法进行深拷贝</span></span><br><span class="line">deep_copy_dict = copy.deepcopy(original_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改新字典中的元素</span></span><br><span class="line">deep_copy_dict[<span class="string">&quot;numbers&quot;</span>].append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Original:&quot;</span>, original_dict)  <span class="comment"># 输出：&#123;&#x27;numbers&#x27;: [1, 2, 3], &#x27;letters&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Deep Copy:&quot;</span>, deep_copy_dict)  <span class="comment"># 输出：&#123;&#x27;numbers&#x27;: [1, 2, 3, 4], &#x27;letters&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>deep_copy_dict</code>是<code>original_dict</code>的深拷贝。即使<code>numbers</code>列表中的内容被修改，<code>original_dict</code>的内容保持不变，因为深拷贝创建了独立的对象。</p>
<h2 id="浅拷贝与深拷贝的区别"><a href="#浅拷贝与深拷贝的区别" class="headerlink" title="浅拷贝与深拷贝的区别"></a>浅拷贝与深拷贝的区别</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><ul>
<li>浅拷贝创建一个新对象，但不会复制对象中嵌套的可变对象的内容。相反，嵌套对象的引用被复制到新对象中，导致新旧对象共享这些嵌套对象。</li>
<li>浅拷贝适用于只需要复制对象本身的场景，而不需要独立的嵌套对象。</li>
</ul>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ul>
<li>深拷贝创建一个新对象，并递归地复制所有的嵌套对象。新对象与原始对象完全独立，修改新对象的任何部分都不会影响原始对象。</li>
<li>深拷贝适用于需要完全独立于原始对象的场景，尤其是当对象中包含嵌套的可变对象时。</li>
</ul>
<h2 id="拷贝的注意事项"><a href="#拷贝的注意事项" class="headerlink" title="拷贝的注意事项"></a>拷贝的注意事项</h2><h3 id="拷贝与对象类型"><a href="#拷贝与对象类型" class="headerlink" title="拷贝与对象类型"></a>拷贝与对象类型</h3><p>在使用浅拷贝和深拷贝时，必须考虑到对象类型。例如，对于不可变类型（如整数、浮点数、字符串和元组），它们本身不受拷贝方式的影响，因为不可变对象一旦创建就无法修改，因此即使是浅拷贝，修改新对象也不会影响原始对象。</p>
<h3 id="对于自定义对象的拷贝"><a href="#对于自定义对象的拷贝" class="headerlink" title="对于自定义对象的拷贝"></a>对于自定义对象的拷贝</h3><p>对于自定义类的对象，浅拷贝和深拷贝的行为和内建数据类型略有不同。如果类的实例包含可变对象作为属性，那么浅拷贝会导致共享这些可变属性，而深拷贝则会创建独立的副本。</p>
<hr>
<h1 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h1><h2 id="Python中的多进程与多线程"><a href="#Python中的多进程与多线程" class="headerlink" title="Python中的多进程与多线程"></a>Python中的多进程与多线程</h2><p>Python的多进程和多线程是提高程序并发性的两种方式。它们都可以用来执行并行任务，但它们的实现原理和适用场景不同。理解它们的区别和使用场景对于编写高效的并发程序至关重要。</p>
<h3 id="多进程（Multiprocessing）"><a href="#多进程（Multiprocessing）" class="headerlink" title="多进程（Multiprocessing）"></a>多进程（Multiprocessing）</h3><p>多进程是指使用多个进程来执行任务，每个进程都有自己的内存空间和资源。进程之间相互独立，互不干扰。Python的<code>multiprocessing</code>模块提供了创建和管理进程的功能。</p>
<h4 id="多进程的特点"><a href="#多进程的特点" class="headerlink" title="多进程的特点"></a>多进程的特点</h4><ul>
<li><strong>独立的内存空间</strong>：每个进程都有自己的内存空间，进程之间不会共享数据。</li>
<li><strong>适用于CPU密集型任务</strong>：由于每个进程都独立运行，因此它们可以在多核CPU上并行执行，适合CPU密集型任务。</li>
<li><strong>进程间通信（IPC）</strong>：进程间的数据传输可以通过队列、管道等方式进行，<code>multiprocessing</code>模块提供了这些工具。</li>
</ul>
<h4 id="创建多进程"><a href="#创建多进程" class="headerlink" title="创建多进程"></a>创建多进程</h4><p>可以使用<code>multiprocessing</code>模块的<code>Process</code>类来创建并启动新的进程。每个进程执行一个目标函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义进程执行的任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Process <span class="subst">&#123;name&#125;</span> started&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Process <span class="subst">&#123;name&#125;</span> finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    processes = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启动多个进程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        p = multiprocessing.Process(target=task, args=(i,))</span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待所有进程完成</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All processes are done&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，创建了三个进程，每个进程执行<code>task</code>函数，并打印相关信息。<code>start()</code>方法启动进程，<code>join()</code>方法确保主进程等待所有子进程完成后再结束。</p>
<h4 id="多进程的优势与劣势"><a href="#多进程的优势与劣势" class="headerlink" title="多进程的优势与劣势"></a>多进程的优势与劣势</h4><ul>
<li><strong>优势</strong>：<ul>
<li>每个进程有独立的内存空间，避免了多线程中的全局变量共享问题。</li>
<li>适用于CPU密集型任务，可以充分利用多核CPU。</li>
</ul>
</li>
<li><strong>劣势</strong>：<ul>
<li>启动和管理进程的开销比线程大。</li>
<li>进程间通信比线程间通信复杂，通常需要使用队列、管道等工具。</li>
</ul>
</li>
</ul>
<h3 id="多线程（Multithreading）"><a href="#多线程（Multithreading）" class="headerlink" title="多线程（Multithreading）"></a>多线程（Multithreading）</h3><p>多线程是指在同一进程中创建多个线程来执行任务。线程之间共享同一进程的内存空间，因此线程间的通信比进程间更为高效。</p>
<h4 id="多线程的特点"><a href="#多线程的特点" class="headerlink" title="多线程的特点"></a>多线程的特点</h4><ul>
<li><strong>共享内存空间</strong>：线程间共享数据，因此可以直接访问和修改共享数据。</li>
<li><strong>适用于I&#x2F;O密集型任务</strong>：Python的GIL（全局解释器锁）使得多线程在执行计算密集型任务时不能有效并行执行，但在I&#x2F;O密集型任务（如文件读写、网络请求）中，多线程可以显著提高性能。</li>
<li><strong>线程间通信</strong>：线程之间的数据共享比较简单，但需要小心竞争条件和死锁问题。</li>
</ul>
<h4 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h4><p>可以使用<code>threading</code>模块来创建和管理线程。每个线程执行一个目标函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义线程执行的任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Thread <span class="subst">&#123;name&#125;</span> started&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Thread <span class="subst">&#123;name&#125;</span> finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    threads = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启动多个线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=task, args=(i,))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All threads are done&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，创建了三个线程，每个线程执行<code>task</code>函数，<code>start()</code>方法启动线程，<code>join()</code>方法确保主线程等待所有子线程完成后再结束。</p>
<h4 id="多线程的优势与劣势"><a href="#多线程的优势与劣势" class="headerlink" title="多线程的优势与劣势"></a>多线程的优势与劣势</h4><ul>
<li><strong>优势</strong>：<ul>
<li>线程间共享内存，通信开销较小。</li>
<li>适用于I&#x2F;O密集型任务，能在等待I&#x2F;O操作时并发执行其他任务。</li>
</ul>
</li>
<li><strong>劣势</strong>：<ul>
<li>Python的GIL限制了多线程的并行执行，尤其在CPU密集型任务中，多个线程无法真正并行执行。</li>
<li>线程间的共享内存需要小心处理，可能会出现竞争条件、死锁等问题。</li>
</ul>
</li>
</ul>
<h3 id="Python中的GIL（全局解释器锁）"><a href="#Python中的GIL（全局解释器锁）" class="headerlink" title="Python中的GIL（全局解释器锁）"></a>Python中的GIL（全局解释器锁）</h3><p>GIL（Global Interpreter Lock）是Python解释器中的一种机制，它确保在任何时刻只有一个线程能执行Python字节码。GIL使得多线程在进行CPU密集型任务时无法实现真正的并行计算，因为即使有多个CPU核心，Python程序仍然只能在一个核心上执行字节码。</p>
<p>然而，GIL并不影响I&#x2F;O密集型任务。在进行文件操作、网络请求等I&#x2F;O操作时，线程会释放GIL，允许其他线程执行，从而实现并发。</p>
<h3 id="选择多进程还是多线程"><a href="#选择多进程还是多线程" class="headerlink" title="选择多进程还是多线程"></a>选择多进程还是多线程</h3><ul>
<li><strong>多进程</strong>适用于CPU密集型任务，能够充分利用多核CPU进行并行处理，避免GIL的限制。</li>
<li><strong>多线程</strong>适用于I&#x2F;O密集型任务，能够有效提高程序在进行网络请求、文件操作等I&#x2F;O操作时的效率。</li>
</ul>
<h2 id="进程与线程的通信"><a href="#进程与线程的通信" class="headerlink" title="进程与线程的通信"></a>进程与线程的通信</h2><h3 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h3><p>在Python中，进程间通信可以使用<code>multiprocessing</code>模块提供的队列、管道等工具进行。由于每个进程都有独立的内存空间，因此必须使用这些工具进行数据交换。</p>
<p><strong>使用队列进行进程间通信</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">q</span>):</span><br><span class="line">    q.put(<span class="string">&quot;Hello from process&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    queue = multiprocessing.Queue()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建并启动进程</span></span><br><span class="line">    p = multiprocessing.Process(target=worker, args=(queue,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取进程间通信的结果</span></span><br><span class="line">    <span class="built_in">print</span>(queue.get())  <span class="comment"># 输出：Hello from process</span></span><br></pre></td></tr></table></figure>

<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>线程之间可以通过共享内存（如列表、字典等）进行通信，但需要注意线程安全问题。可以使用<code>threading</code>模块中的锁（Lock）来确保线程安全。</p>
<p><strong>使用锁进行线程间通信</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">lock</span>):</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Thread is working&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    </span><br><span class="line">    threads = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=worker, args=(lock,))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br></pre></td></tr></table></figure>

<p>在这个示例中，使用了<code>Lock</code>来确保多个线程在打印时不会发生竞争条件。</p>
<hr>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="进程间通信（IPC）-1"><a href="#进程间通信（IPC）-1" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h2><p>进程间通信（IPC, Inter-Process Communication）是指在多个进程之间交换数据和信息。由于每个进程拥有独立的内存空间，进程间的通信不像线程之间那样直接，因此需要通过特定的方式来进行数据传输。Python的<code>multiprocessing</code>模块提供了多种进程间通信的方法，包括<strong>队列（Queue）</strong>、<strong>管道（Pipe）</strong>、和 **共享内存（Value&#x2F;Array）**等。</p>
<h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><p>队列是进程间通信中最常用的方式之一。它是一个线程安全的队列，支持在多个进程之间传递数据。进程通过队列将数据放入（<code>put()</code>）和取出（<code>get()</code>），实现进程间的数据传输。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">q</span>):</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    q.put(<span class="string">&quot;Hello from the process!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建队列</span></span><br><span class="line">    queue = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建进程并启动</span></span><br><span class="line">    process = multiprocessing.Process(target=worker, args=(queue,))</span><br><span class="line">    process.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待进程完成</span></span><br><span class="line">    process.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从队列中获取数据</span></span><br><span class="line">    result = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(result)  <span class="comment"># 输出：Hello from the process!</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>queue.put()</code>将数据放入队列，<code>queue.get()</code>从队列中读取数据。队列的一个重要特点是它是线程安全的，可以在多个进程间安全地传递数据。</p>
<h2 id="管道（Pipe）"><a href="#管道（Pipe）" class="headerlink" title="管道（Pipe）"></a>管道（Pipe）</h2><p>管道是另一种简单的进程间通信机制，适用于两个进程之间的数据传输。管道提供了两端，一端写入数据，另一端读取数据。管道适用于数据量较小或两个进程之间的简单通信。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">pipe</span>):</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    pipe.send(<span class="string">&quot;Hello from the process!&quot;</span>)  <span class="comment"># 向管道发送数据</span></span><br><span class="line">    pipe.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建管道</span></span><br><span class="line">    parent_conn, child_conn = multiprocessing.Pipe()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建进程并启动</span></span><br><span class="line">    process = multiprocessing.Process(target=worker, args=(child_conn,))</span><br><span class="line">    process.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从管道接收数据</span></span><br><span class="line">    result = parent_conn.recv()</span><br><span class="line">    <span class="built_in">print</span>(result)  <span class="comment"># 输出：Hello from the process!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待进程完成</span></span><br><span class="line">    process.join()</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Pipe()</code>创建了一个管道，<code>parent_conn</code>和<code>child_conn</code>分别代表管道的两端。进程通过<code>child_conn.send()</code>将数据发送到管道，主进程通过<code>parent_conn.recv()</code>接收数据。</p>
<h2 id="共享内存（Value-Array）"><a href="#共享内存（Value-Array）" class="headerlink" title="共享内存（Value&#x2F;Array）"></a>共享内存（Value&#x2F;Array）</h2><p>共享内存是另一种进程间通信的方式，允许多个进程访问同一内存区域。<code>Value</code>和<code>Array</code>是<code>multiprocessing</code>模块提供的共享内存对象，分别用于存储单一的值和数组。</p>
<h3 id="使用Value进行共享内存通信"><a href="#使用Value进行共享内存通信" class="headerlink" title="使用Value进行共享内存通信"></a>使用<code>Value</code>进行共享内存通信</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">val</span>):</span><br><span class="line">    val.value += <span class="number">1</span>  <span class="comment"># 修改共享内存中的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建共享内存变量</span></span><br><span class="line">    shared_value = multiprocessing.Value(<span class="string">&#x27;i&#x27;</span>, <span class="number">0</span>)  <span class="comment"># &#x27;i&#x27;表示整型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建多个进程并启动</span></span><br><span class="line">    processes = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=worker, args=(shared_value,))</span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待进程完成</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Shared value: <span class="subst">&#123;shared_value.value&#125;</span>&quot;</span>)  <span class="comment"># 输出：Shared value: 5</span></span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>shared_value</code>是一个共享内存变量，多个进程都能访问并修改它的值。<code>multiprocessing.Value</code>创建了一个共享的整型变量。</p>
<h3 id="使用Array进行共享内存通信"><a href="#使用Array进行共享内存通信" class="headerlink" title="使用Array进行共享内存通信"></a>使用<code>Array</code>进行共享内存通信</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">arr</span>):</span><br><span class="line">    arr[<span class="number">0</span>] += <span class="number">1</span>  <span class="comment"># 修改共享数组中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建共享内存数组</span></span><br><span class="line">    shared_array = multiprocessing.Array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># &#x27;i&#x27;表示整型数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建多个进程并启动</span></span><br><span class="line">    processes = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=worker, args=(shared_array,))</span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待进程完成</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Shared array: <span class="subst">&#123;<span class="built_in">list</span>(shared_array)&#125;</span>&quot;</span>)  <span class="comment"># 输出：Shared array: [5, 0, 0]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>shared_array</code>是一个共享的整数数组，多个进程并发地修改数组的内容。<code>multiprocessing.Array</code>提供了一个共享内存数组，进程间可以直接修改它的元素。</p>
<h2 id="进程间通信的同步"><a href="#进程间通信的同步" class="headerlink" title="进程间通信的同步"></a>进程间通信的同步</h2><p>在进程间共享内存时，由于多个进程可能同时修改共享数据，因此需要使用同步机制，防止数据竞争或出现不一致的情况。<code>multiprocessing</code>模块提供了多种同步工具，例如<code>Lock</code>、<code>Semaphore</code>等。</p>
<h3 id="使用Lock同步进程"><a href="#使用Lock同步进程" class="headerlink" title="使用Lock同步进程"></a>使用<code>Lock</code>同步进程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">lock, shared_value</span>):</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        shared_value.value += <span class="number">1</span>  <span class="comment"># 确保对共享值的访问是互斥的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    lock = multiprocessing.Lock()</span><br><span class="line">    shared_value = multiprocessing.Value(<span class="string">&#x27;i&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    processes = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=worker, args=(lock, shared_value))</span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Shared value: <span class="subst">&#123;shared_value.value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>Lock</code>用于确保每次只有一个进程能够访问共享资源<code>shared_value</code>。通过<code>with lock</code>确保每个进程在修改共享数据时是互斥的，避免数据竞争。</p>
<hr>
<h1 id="线程间通信-1"><a href="#线程间通信-1" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>线程间通信（Inter-Thread Communication）指的是在多个线程之间传递数据和信息。不同于进程间通信，线程是共享同一进程的内存空间，因此它们可以直接访问共享的资源和数据。线程间通信相对简单，但也需要小心数据竞争和线程同步问题。Python通过<code>threading</code>模块提供了多种线程间通信的方式，包括<strong>共享内存</strong>、<strong>队列（Queue）</strong>、以及**事件（Event）**等。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>由于所有线程都共享进程的内存空间，它们可以直接访问全局变量或共享对象。这种方式适合一些简单的场景，但需要注意线程间的同步问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享变量</span></span><br><span class="line">shared_value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>():</span><br><span class="line">    <span class="keyword">global</span> shared_value</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        shared_value += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Thread updated shared_value: <span class="subst">&#123;shared_value&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    threads = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启动多个线程</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=worker)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Final shared_value: <span class="subst">&#123;shared_value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>shared_value</code>是多个线程共享的变量。所有线程都可以直接访问并修改它。由于线程之间是并发执行的，在没有同步机制的情况下，可能会导致数据竞争问题，即多个线程同时修改共享变量，导致结果不一致。</p>
<h2 id="队列（Queue）-1"><a href="#队列（Queue）-1" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><p><code>queue.Queue</code>是线程安全的，可以在多个线程之间传递数据。通过<code>put()</code>和<code>get()</code>方法，线程可以将数据放入队列或者从队列中取出数据。<code>Queue</code>实现了生产者-消费者模式，适用于多个线程之间传递数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        q.put(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Produced: <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = q.get()</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 结束标志</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Consumed: <span class="subst">&#123;item&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    q = queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动生产者和消费者线程</span></span><br><span class="line">    producer_thread = threading.Thread(target=producer, args=(q,))</span><br><span class="line">    consumer_thread = threading.Thread(target=consumer, args=(q,))</span><br><span class="line"></span><br><span class="line">    producer_thread.start()</span><br><span class="line">    consumer_thread.start()</span><br><span class="line"></span><br><span class="line">    producer_thread.join()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 向队列中添加None作为结束标志</span></span><br><span class="line">    q.put(<span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    consumer_thread.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All tasks are completed.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>producer</code>线程将数据放入队列，而<code>consumer</code>线程从队列中获取数据并进行处理。为了结束<code>consumer</code>线程，我们向队列中放入了<code>None</code>，作为一个结束信号。使用队列可以避免多线程间共享内存的复杂性，并且<code>queue.Queue</code>本身是线程安全的。</p>
<h2 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h2><p><code>threading.Event</code>是一个简单的同步原语，用于线程之间的信号传递。一个线程可以设置事件状态为“已触发”，其他线程可以等待事件被触发。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wait_for_event</span>(<span class="params">e</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Thread is waiting for the event to be set.&quot;</span>)</span><br><span class="line">    e.wait()  <span class="comment"># 阻塞，直到事件被触发</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Event is set! Thread is resuming.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trigger_event</span>(<span class="params">e</span>):</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Setting event...&quot;</span>)</span><br><span class="line">    e.<span class="built_in">set</span>()  <span class="comment"># 设置事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动等待事件的线程</span></span><br><span class="line">    thread1 = threading.Thread(target=wait_for_event, args=(event,))</span><br><span class="line">    <span class="comment"># 启动触发事件的线程</span></span><br><span class="line">    thread2 = threading.Thread(target=trigger_event, args=(event,))</span><br><span class="line"></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All tasks are completed.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>wait_for_event</code>线程在调用<code>e.wait()</code>时会被阻塞，直到<code>trigger_event</code>线程调用<code>e.set()</code>来触发事件。<code>Event</code>用于在一个线程中设置某种条件，然后其他线程等待这个条件的发生。</p>
<h2 id="锁（Lock）"><a href="#锁（Lock）" class="headerlink" title="锁（Lock）"></a>锁（Lock）</h2><p><code>Lock</code>用于确保只有一个线程能够访问共享资源。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>():</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="comment"># 临界区：只有一个线程能在这里执行</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;threading.current_thread().name&#125;</span> is working.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    threads = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=worker)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All threads have finished.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Lock</code>用于同步多个线程的访问。通过<code>with lock</code>语句确保只有一个线程能进入临界区执行操作，避免多个线程同时修改共享资源。</p>
<h2 id="条件（Condition）"><a href="#条件（Condition）" class="headerlink" title="条件（Condition）"></a>条件（Condition）</h2><p><code>Condition</code>允许线程在特定条件下等待和通知其他线程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">condition = threading.Condition()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    <span class="keyword">with</span> condition:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Consumer is waiting for the event.&quot;</span>)</span><br><span class="line">        condition.wait()  <span class="comment"># 等待被通知</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Consumer is now consuming!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>():</span><br><span class="line">    <span class="keyword">with</span> condition:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Producer is producing something.&quot;</span>)</span><br><span class="line">        condition.notify()  <span class="comment"># 通知等待的线程</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Producer has notified the consumer.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    consumer_thread = threading.Thread(target=consumer)</span><br><span class="line">    producer_thread = threading.Thread(target=producer)</span><br><span class="line"></span><br><span class="line">    consumer_thread.start()</span><br><span class="line">    producer_thread.start()</span><br><span class="line"></span><br><span class="line">    consumer_thread.join()</span><br><span class="line">    producer_thread.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All tasks are completed.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>consumer</code>线程在调用<code>condition.wait()</code>时会被阻塞，直到<code>producer</code>线程调用<code>condition.notify()</code>来通知它继续执行。<code>Condition</code>提供了更复杂的同步机制，适用于需要线程间协调的场景。</p>
<hr>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><h2 id="Lambda表达式的基本语法"><a href="#Lambda表达式的基本语法" class="headerlink" title="Lambda表达式的基本语法"></a>Lambda表达式的基本语法</h2><p>Lambda表达式是Python中用于创建匿名函数的简洁方式。它的基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数<span class="number">1</span>, 参数<span class="number">2</span>, ... : 表达式</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lambda</code>：是Python中用于定义匿名函数的关键字。</li>
<li><code>参数1, 参数2, ...</code>：输入参数，可以有多个，也可以没有。</li>
<li><code>表达式</code>：Lambda函数体，计算并返回一个值。Lambda函数只能包含一个表达式，不能有多条语句。</li>
</ul>
<h2 id="Lambda表达式的示例"><a href="#Lambda表达式的示例" class="headerlink" title="Lambda表达式的示例"></a>Lambda表达式的示例</h2><h3 id="最简单的Lambda表达式"><a href="#最简单的Lambda表达式" class="headerlink" title="最简单的Lambda表达式"></a>最简单的Lambda表达式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">5</span>))  <span class="comment"># 输出：8</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>lambda x, y: x + y</code>创建了一个匿名函数，接受两个参数<code>x</code>和<code>y</code>，并返回它们的和。通过将其赋值给<code>add</code>变量，之后可以调用它。</p>
<h3 id="使用Lambda表达式创建简单的函数"><a href="#使用Lambda表达式创建简单的函数" class="headerlink" title="使用Lambda表达式创建简单的函数"></a>使用Lambda表达式创建简单的函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">square = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"><span class="built_in">print</span>(square(<span class="number">4</span>))  <span class="comment"># 输出：16</span></span><br></pre></td></tr></table></figure>

<p>这里的Lambda表达式用于计算一个数字的平方。</p>
<h2 id="Lambda表达式的应用场景"><a href="#Lambda表达式的应用场景" class="headerlink" title="Lambda表达式的应用场景"></a>Lambda表达式的应用场景</h2><p>Lambda表达式非常适用于那些需要短小、简洁函数的场合，尤其是在一些高阶函数（如<code>map()</code>、<code>filter()</code>、<code>sorted()</code>等）中作为参数传递。</p>
<h3 id="在map-函数中使用Lambda"><a href="#在map-函数中使用Lambda" class="headerlink" title="在map()函数中使用Lambda"></a>在<code>map()</code>函数中使用Lambda</h3><p><code>map()</code>函数用于将指定函数应用于给定序列的每个元素，返回一个迭代器。Lambda表达式非常适合作为<code>map()</code>的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared_numbers = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(squared_numbers))  <span class="comment"># 输出：[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>lambda x: x**2</code>是一个简单的匿名函数，用于计算每个数字的平方，<code>map()</code>函数应用它到<code>numbers</code>列表中的每个元素。</p>
<h3 id="在filter-函数中使用Lambda"><a href="#在filter-函数中使用Lambda" class="headerlink" title="在filter()函数中使用Lambda"></a>在<code>filter()</code>函数中使用Lambda</h3><p><code>filter()</code>函数用于从序列中过滤出符合条件的元素，返回一个新的迭代器。Lambda表达式可以用来定义过滤条件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">even_numbers = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(even_numbers))  <span class="comment"># 输出：[2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>lambda x: x % 2 == 0</code>是一个检查数字是否为偶数的Lambda函数，<code>filter()</code>函数将它应用于<code>numbers</code>列表，筛选出所有偶数。</p>
<h3 id="在sorted-函数中使用Lambda"><a href="#在sorted-函数中使用Lambda" class="headerlink" title="在sorted()函数中使用Lambda"></a>在<code>sorted()</code>函数中使用Lambda</h3><p><code>sorted()</code>函数用于排序序列，可以通过<code>key</code>参数指定排序规则。Lambda表达式常用于快速定义排序规则。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students = [(<span class="string">&quot;Alice&quot;</span>, <span class="number">85</span>), (<span class="string">&quot;Bob&quot;</span>, <span class="number">90</span>), (<span class="string">&quot;Charlie&quot;</span>, <span class="number">78</span>)]</span><br><span class="line">sorted_students = <span class="built_in">sorted</span>(students, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(sorted_students)  <span class="comment"># 输出：[(&#x27;Charlie&#x27;, 78), (&#x27;Alice&#x27;, 85), (&#x27;Bob&#x27;, 90)]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>lambda x: x[1]</code>是一个用于提取每个元组中分数的Lambda函数。<code>sorted()</code>将这个函数应用于<code>students</code>列表，按照分数进行排序。</p>
<h3 id="在reduce-函数中使用Lambda"><a href="#在reduce-函数中使用Lambda" class="headerlink" title="在reduce()函数中使用Lambda"></a>在<code>reduce()</code>函数中使用Lambda</h3><p><code>reduce()</code>函数用于将一个序列中的所有元素通过指定的函数进行累积计算。Lambda表达式通常用于定义累积操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x, y: x + y, numbers)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：15</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>lambda x, y: x + y</code>定义了一个累加操作的Lambda函数，<code>reduce()</code>将其应用于<code>numbers</code>列表中的元素，计算出所有元素的和。</p>
<h2 id="Lambda表达式与普通函数的比较"><a href="#Lambda表达式与普通函数的比较" class="headerlink" title="Lambda表达式与普通函数的比较"></a>Lambda表达式与普通函数的比较</h2><h3 id="定义简洁性"><a href="#定义简洁性" class="headerlink" title="定义简洁性"></a>定义简洁性</h3><p>Lambda表达式通常比普通函数定义更简洁，适用于简单的功能。普通函数定义通常需要更多的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># Lambda表达式</span></span><br><span class="line">add_lambda = <span class="keyword">lambda</span> x, y: x + y</span><br></pre></td></tr></table></figure>

<h3 id="功能限制"><a href="#功能限制" class="headerlink" title="功能限制"></a>功能限制</h3><p>Lambda表达式只能包含一个表达式，而普通函数可以包含多个语句。对于简单的操作，Lambda表达式可以使代码更简洁，但当逻辑较复杂时，普通函数会更加清晰。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">x, y</span>):</span><br><span class="line">    result = x * y</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># Lambda表达式</span></span><br><span class="line">multiply_lambda = <span class="keyword">lambda</span> x, y: x * y  <span class="comment"># 只能包含一条表达式</span></span><br></pre></td></tr></table></figure>

<h3 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h3><p>普通函数通常有名称，可以在多个地方复用。Lambda表达式通常是一次性使用的匿名函数，不需要为它起名字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># Lambda表达式</span></span><br><span class="line">square_lambda = <span class="keyword">lambda</span> x: x * x</span><br></pre></td></tr></table></figure>

<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Lambda表达式的性能与普通函数相差无几。它的优势在于简洁性，对于简单的功能，Lambda表达式能让代码更紧凑。对于复杂的功能，仍然推荐使用普通函数。</p>
<h2 id="Lambda表达式的优缺点"><a href="#Lambda表达式的优缺点" class="headerlink" title="Lambda表达式的优缺点"></a>Lambda表达式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>简洁</strong>：Lambda表达式使代码更简洁，适用于定义简单的函数。</li>
<li><strong>方便</strong>：常用于需要传递函数的地方，如<code>map()</code>、<code>filter()</code>、<code>sorted()</code>等函数。</li>
<li><strong>匿名函数</strong>：不需要为简单的函数定义名字。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><strong>功能限制</strong>：Lambda表达式只能包含一个表达式，无法包含复杂的逻辑或多条语句。</li>
<li><strong>可读性差</strong>：对于复杂的操作，Lambda表达式可能使代码难以理解，应避免过度使用。</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>Lambda表达式</strong>是Python中的匿名函数，可以简洁地定义简单的功能。</li>
<li><strong>应用场景</strong>：主要用于<code>map()</code>、<code>filter()</code>、<code>reduce()</code>等高阶函数中，快速定义操作。</li>
<li><strong>优缺点</strong>：Lambda表达式使代码更加简洁，但适用于简单任务，复杂任务仍然需要使用普通函数。</li>
</ul>
<hr>
<h1 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h1><h2 id="类型注解（Type-Annotation）"><a href="#类型注解（Type-Annotation）" class="headerlink" title="类型注解（Type Annotation）"></a>类型注解（Type Annotation）</h2><p>类型注解是Python的一项功能，允许开发者在代码中显式地指定函数参数和返回值的类型。类型注解本身不会影响程序的执行，它们主要用于提供额外的信息，帮助开发者理解代码的结构，同时可以通过静态类型检查工具（如<code>mypy</code>）来检查代码中的类型一致性。</p>
<p>类型注解是Python 3.5引入的特性，随着时间的发展，它逐渐成为开发人员提高代码可读性和可维护性的一项重要工具。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="函数参数的类型注解"><a href="#函数参数的类型注解" class="headerlink" title="函数参数的类型注解"></a>函数参数的类型注解</h3><p>在函数定义中，可以使用冒号<code>:</code>后跟类型来为每个参数指定类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>

<p>在这个例子中，函数<code>add</code>接受两个<code>int</code>类型的参数，并返回一个<code>int</code>类型的结果。类型注解指定了<code>a</code>和<code>b</code>的类型是<code>int</code>，并且指定了返回值类型为<code>int</code>。</p>
<h3 id="变量的类型注解"><a href="#变量的类型注解" class="headerlink" title="变量的类型注解"></a>变量的类型注解</h3><p>Python也支持在变量声明时添加类型注解，虽然类型注解不会影响变量的实际行为，但它提供了对变量类型的提示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x: <span class="built_in">int</span> = <span class="number">5</span></span><br><span class="line">y: <span class="built_in">str</span> = <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里，<code>x</code>被注解为<code>int</code>类型，<code>y</code>被注解为<code>str</code>类型。这样做有助于提高代码的可读性，尤其是在较大的项目中，明确变量类型非常重要。</p>
<h3 id="复合类型注解"><a href="#复合类型注解" class="headerlink" title="复合类型注解"></a>复合类型注解</h3><p>对于更复杂的类型，可以使用Python的内建类型（如<code>List</code>、<code>Dict</code>、<code>Tuple</code>等）来进行注解。Python的<code>typing</code>模块提供了这些类型。</p>
<h4 id="列表的类型注解"><a href="#列表的类型注解" class="headerlink" title="列表的类型注解"></a>列表的类型注解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_list</span>(<span class="params">numbers: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(numbers)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>numbers</code>被注解为一个<code>int</code>类型的列表，表示函数接受一个<code>int</code>类型的列表，并返回一个<code>int</code>类型的结果。</p>
<h4 id="字典的类型注解"><a href="#字典的类型注解" class="headerlink" title="字典的类型注解"></a>字典的类型注解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_name_age</span>(<span class="params">person: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;person[<span class="string">&#x27;name&#x27;</span>]&#125;</span> is <span class="subst">&#123;person[<span class="string">&#x27;age&#x27;</span>]&#125;</span> years old&quot;</span></span><br></pre></td></tr></table></figure>

<p>此例中，<code>person</code>被注解为一个字典，字典的键是<code>str</code>类型，值是<code>int</code>类型。</p>
<h4 id="元组的类型注解"><a href="#元组的类型注解" class="headerlink" title="元组的类型注解"></a>元组的类型注解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coordinates</span>() -&gt; <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>coordinates()</code>函数返回一个包含两个<code>int</code>类型值的元组。</p>
<h3 id="可选类型（Optional）"><a href="#可选类型（Optional）" class="headerlink" title="可选类型（Optional）"></a>可选类型（Optional）</h3><p>有时，函数的参数或返回值可能是某种类型，或者是<code>None</code>。这种情况下，可以使用<code>Optional</code>来表示这种可能性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_name</span>(<span class="params">names: <span class="type">List</span>[<span class="built_in">str</span>], name: <span class="built_in">str</span></span>) -&gt; <span class="type">Optional</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> names:</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>find_name</code>函数返回一个<code>str</code>类型的值，或者返回<code>None</code>。通过<code>Optional[str]</code>，我们明确了返回值的类型要么是<code>str</code>，要么是<code>None</code>。</p>
<h3 id="类型别名（Type-Aliases）"><a href="#类型别名（Type-Aliases）" class="headerlink" title="类型别名（Type Aliases）"></a>类型别名（Type Aliases）</h3><p>如果你想给复杂的类型定义一个别名，可以使用<code>TypeVar</code>和<code>Type</code>。这对于提高代码可读性非常有用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line">Point = <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>]  <span class="comment"># 定义类型别名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">p1: Point, p2: Point</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> ((p1[<span class="number">0</span>] - p2[<span class="number">0</span>]) ** <span class="number">2</span> + (p1[<span class="number">1</span>] - p2[<span class="number">1</span>]) ** <span class="number">2</span>) ** <span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Point</code>是<code>Tuple[int, int]</code>的类型别名，表示一个二维点的坐标。通过给类型创建别名，代码更简洁并且易于理解。</p>
<h3 id="联合类型（Union）"><a href="#联合类型（Union）" class="headerlink" title="联合类型（Union）"></a>联合类型（Union）</h3><p>有时，变量或者函数的返回值可能有多种类型。可以使用<code>Union</code>来表示一个类型可以是多个类型之一。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_value</span>(<span class="params">val: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(val)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>val</code>的类型可能是<code>int</code>或<code>str</code>，通过<code>Union[int, str]</code>来表示这种可能性。</p>
<h3 id="类型推导与静态检查"><a href="#类型推导与静态检查" class="headerlink" title="类型推导与静态检查"></a>类型推导与静态检查</h3><p>尽管Python是动态类型语言，类型注解本身并不会影响程序的运行。Python的类型注解通常依赖于静态类型检查工具（如<code>mypy</code>）来进行验证。</p>
<h4 id="示例：使用mypy进行类型检查"><a href="#示例：使用mypy进行类型检查" class="headerlink" title="示例：使用mypy进行类型检查"></a>示例：使用<code>mypy</code>进行类型检查</h4><ol>
<li>首先，安装<code>mypy</code>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mypy</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后，你可以使用<code>mypy</code>来检查你的代码：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mypy your_script.py</span><br></pre></td></tr></table></figure>

<p><code>mypy</code>将根据类型注解检查你的代码是否存在类型不匹配的错误。</p>
<h2 id="类型注解的优势"><a href="#类型注解的优势" class="headerlink" title="类型注解的优势"></a>类型注解的优势</h2><h3 id="增强代码可读性"><a href="#增强代码可读性" class="headerlink" title="增强代码可读性"></a>增强代码可读性</h3><p>类型注解能够清楚地表明函数和变量的类型，使代码的意图更加明确，特别是在大型项目中，帮助开发者快速理解代码。</p>
<h3 id="提高代码质量"><a href="#提高代码质量" class="headerlink" title="提高代码质量"></a>提高代码质量</h3><p>类型注解可以让你在开发过程中提前发现一些潜在的类型错误。通过静态类型检查工具，开发者可以在程序运行之前发现类型不匹配的地方，避免因类型问题导致的运行时错误。</p>
<h3 id="增加开发效率"><a href="#增加开发效率" class="headerlink" title="增加开发效率"></a>增加开发效率</h3><p>当函数参数和返回值的类型明确时，IDE（集成开发环境）可以提供更好的自动补全、类型提示和错误检查，帮助开发者减少错误并提高开发效率。</p>
<h2 id="类型注解的限制"><a href="#类型注解的限制" class="headerlink" title="类型注解的限制"></a>类型注解的限制</h2><h3 id="1-类型注解并不强制执行"><a href="#1-类型注解并不强制执行" class="headerlink" title="1. 类型注解并不强制执行"></a>1. 类型注解并不强制执行</h3><p>Python的类型注解并不会强制执行类型检查。它们仅供开发者参考，或者通过静态类型检查工具（如<code>mypy</code>）来验证类型一致性。Python本身在运行时并不检查类型，因此程序在运行时不会因为类型错误而抛出异常。</p>
<h3 id="2-动态类型语言的灵活性丧失"><a href="#2-动态类型语言的灵活性丧失" class="headerlink" title="2. 动态类型语言的灵活性丧失"></a>2. 动态类型语言的灵活性丧失</h3><p>虽然类型注解提高了代码的可读性和可靠性，但它也减少了Python作为动态类型语言的灵活性。开发者在定义类型时需要更加严格地遵循规范，这在某些情况下可能会限制代码的灵活性。</p>
<hr>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="装饰器的概念"><a href="#装饰器的概念" class="headerlink" title="装饰器的概念"></a>装饰器的概念</h2><p>在Python中，**装饰器（Decorator）**是一个用于修改或扩展函数或方法功能的高级特性。装饰器本质上是一个函数，它接受一个函数作为输入，并返回一个新的函数。装饰器通常用于增加函数的功能，而无需修改原有的函数代码。</p>
<p>装饰器的核心思想是通过将额外的功能封装到一个装饰器函数中，来“装饰”原始函数，从而实现代码的复用和功能扩展。</p>
<h2 id="装饰器的基本语法"><a href="#装饰器的基本语法" class="headerlink" title="装饰器的基本语法"></a>装饰器的基本语法</h2><p>装饰器是一个函数，它接受一个函数作为参数，并返回一个新的函数。在Python中，可以通过<code>@</code>符号来使用装饰器，语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">function = decorator(function)</span><br></pre></td></tr></table></figure>

<h3 id="示例：最简单的装饰器"><a href="#示例：最简单的装饰器" class="headerlink" title="示例：最简单的装饰器"></a>示例：最简单的装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Before function call.&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;After function call.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@simple_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>simple_decorator</code>是一个装饰器，它接受一个函数<code>func</code>，并返回一个新的函数<code>wrapper</code>。<code>wrapper</code>在调用<code>func</code>之前和之后分别打印一些内容。当我们使用<code>@simple_decorator</code>语法时，<code>say_hello</code>函数被<code>simple_decorator</code>装饰，调用<code>say_hello()</code>时实际上会执行装饰器中的<code>wrapper</code>函数。</p>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before function call.</span><br><span class="line">Hello!</span><br><span class="line">After function call.</span><br></pre></td></tr></table></figure>

<h2 id="装饰器的应用"><a href="#装饰器的应用" class="headerlink" title="装饰器的应用"></a>装饰器的应用</h2><p>装饰器常用于多种场景，主要用于增强函数或方法的功能。常见的应用场景包括：</p>
<ol>
<li><strong>日志记录</strong>：在函数调用前后记录日志。</li>
<li><strong>权限检查</strong>：在执行函数之前检查用户权限。</li>
<li><strong>缓存</strong>：缓存函数的计算结果，避免重复计算。</li>
</ol>
<h3 id="示例：装饰器用于日志记录"><a href="#示例：装饰器用于日志记录" class="headerlink" title="示例：装饰器用于日志记录"></a>示例：装饰器用于日志记录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Calling function <span class="subst">&#123;func.__name__&#125;</span> with arguments <span class="subst">&#123;args&#125;</span> and <span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Function <span class="subst">&#123;func.__name__&#125;</span> returned <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>log_decorator</code>是一个装饰器，它会在函数调用前打印函数名称、参数，以及函数执行后的返回值。装饰器<code>@log_decorator</code>装饰了<code>add</code>函数，使得每次调用<code>add</code>时都会执行日志记录。</p>
<h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calling function add with arguments (2, 3) and &#123;&#125;</span><br><span class="line">Function add returned 5</span><br></pre></td></tr></table></figure>

<h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>有时，我们希望装饰器接受一些参数来定制装饰器的行为。在这种情况下，装饰器本身需要再嵌套一层函数，以便接收参数。</p>
<h3 id="示例：带参数的装饰器"><a href="#示例：带参数的装饰器" class="headerlink" title="示例：带参数的装饰器"></a>示例：带参数的装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeat_decorator</span>(<span class="params">times</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">                result = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat_decorator(<span class="params">times=<span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>repeat_decorator</code>是一个带参数的装饰器，它接受<code>times</code>作为参数，并将<code>func</code>执行指定的次数。在这个例子中，<code>greet(&quot;Alice&quot;)</code>会打印三次<code>Hello, Alice!</code>。</p>
<h3 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, Alice!</span><br><span class="line">Hello, Alice!</span><br><span class="line">Hello, Alice!</span><br></pre></td></tr></table></figure>

<h2 id="装饰器与函数参数"><a href="#装饰器与函数参数" class="headerlink" title="装饰器与函数参数"></a>装饰器与函数参数</h2><p>装饰器通常是为了包装原始函数，但如果函数有参数，我们也可以使用<code>*args</code>和<code>**kwargs</code>来确保装饰器适用于任何参数类型的函数。</p>
<h3 id="示例：装饰器与函数参数"><a href="#示例：装饰器与函数参数" class="headerlink" title="示例：装饰器与函数参数"></a>示例：装饰器与函数参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Before function call&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;After function call&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@greet_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;name&#125;</span>, you are <span class="subst">&#123;age&#125;</span> years old.&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>greet</code>函数接受两个参数<code>name</code>和<code>age</code>，<code>greet_decorator</code>装饰器通过<code>*args</code>和<code>**kwargs</code>处理这些参数。</p>
<h3 id="输出：-3"><a href="#输出：-3" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before function call</span><br><span class="line">Hello Alice, you are 30 years old.</span><br><span class="line">After function call</span><br></pre></td></tr></table></figure>

<h2 id="装饰器的嵌套使用"><a href="#装饰器的嵌套使用" class="headerlink" title="装饰器的嵌套使用"></a>装饰器的嵌套使用</h2><p>多个装饰器可以同时应用于一个函数，装饰器按照从下到上的顺序执行。</p>
<h3 id="示例：多个装饰器"><a href="#示例：多个装饰器" class="headerlink" title="示例：多个装饰器"></a>示例：多个装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator_1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Decorator 1&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator_2</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Decorator 2&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_1</span></span><br><span class="line"><span class="meta">@decorator_2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>say_hello</code>函数被两个装饰器装饰。装饰器的执行顺序是从下到上，因此<code>decorator_2</code>先执行，然后是<code>decorator_1</code>。</p>
<h3 id="输出：-4"><a href="#输出：-4" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Decorator 1</span><br><span class="line">Decorator 2</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure>

<h2 id="functools-wraps：保留原函数的元数据"><a href="#functools-wraps：保留原函数的元数据" class="headerlink" title="functools.wraps：保留原函数的元数据"></a><code>functools.wraps</code>：保留原函数的元数据</h2><p>当我们使用装饰器时，原函数的一些元数据（如函数名、文档字符串等）会丢失。如果我们希望装饰器能够保留原函数的这些元数据，可以使用<code>functools.wraps</code>。</p>
<h3 id="示例：使用functools-wraps"><a href="#示例：使用functools-wraps" class="headerlink" title="示例：使用functools.wraps"></a>示例：使用<code>functools.wraps</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Before function call&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@simple_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This is a greeting function.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(say_hello.__name__)  <span class="comment"># 输出：say_hello</span></span><br><span class="line"><span class="built_in">print</span>(say_hello.__doc__)   <span class="comment"># 输出：This is a greeting function.</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，使用了<code>@wraps(func)</code>来确保装饰器不会丢失原函数的<code>__name__</code>和<code>__doc__</code>等元数据。否则，装饰器会导致<code>say_hello</code>函数的元数据丢失。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>装饰器</strong>是一个接受函数作为输入并返回一个新函数的高阶函数，用于扩展函数或方法的功能。</li>
<li><strong>基本语法</strong>：使用<code>@decorator</code>语法来装饰函数，装饰器本质上是一个包装函数。</li>
<li><strong>带参数的装饰器</strong>：可以通过嵌套函数来创建带参数的装饰器。</li>
<li><strong>多个装饰器</strong>：可以使用多个装饰器来装饰一个函数，装饰器按从下到上的顺序执行。</li>
<li><code>**functools.wraps**</code>：确保装饰器能够保留原函数的元数据（如<code>__name__</code>和<code>__doc__</code>等）。</li>
</ul>
<p>装饰器为Python提供了一个强大的工具，可以在不修改函数内部代码的情况下，灵活地增加或修改其行为。</p>
<hr>
<h1 id="生成器和迭代器"><a href="#生成器和迭代器" class="headerlink" title="生成器和迭代器"></a>生成器和迭代器</h1><h2 id="生成器与迭代器"><a href="#生成器与迭代器" class="headerlink" title="生成器与迭代器"></a>生成器与迭代器</h2><p>在Python中，生成器（Generator）和迭代器（Iterator）是用于实现迭代操作的两种重要工具。它们都用于遍历一个集合或序列中的元素，但它们的工作方式和实现原理有所不同。理解生成器和迭代器的区别和使用场景对编写高效的Python代码非常重要。</p>
<h2 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h2><h3 id="迭代器的定义"><a href="#迭代器的定义" class="headerlink" title="迭代器的定义"></a>迭代器的定义</h3><p>迭代器是一个对象，它实现了<code>__iter__()</code>和<code>__next__()</code>方法。这使得该对象可以被迭代，从而依次返回集合中的元素。</p>
<ul>
<li><code>__iter__()</code>：返回一个迭代器对象，通常返回<code>self</code>。</li>
<li><code>__next__()</code>：返回集合中的下一个元素。如果没有更多元素，抛出<code>StopIteration</code>异常。</li>
</ul>
<h3 id="创建迭代器"><a href="#创建迭代器" class="headerlink" title="创建迭代器"></a>创建迭代器</h3><p>Python中的<code>list</code>、<code>tuple</code>、<code>dict</code>等容器类型本身就已经是可迭代的，也就是说，它们是默认的迭代器。我们可以使用<code>iter()</code>函数将这些容器类型转化为迭代器，并使用<code>next()</code>函数进行遍历。</p>
<h4 id="示例：使用迭代器遍历列表"><a href="#示例：使用迭代器遍历列表" class="headerlink" title="示例：使用迭代器遍历列表"></a>示例：使用迭代器遍历列表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">iterator = <span class="built_in">iter</span>(numbers)  <span class="comment"># 创建迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(iterator))  <span class="comment"># 输出：1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(iterator))  <span class="comment"># 输出：2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(iterator))  <span class="comment"># 输出：3</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>iter(numbers)</code>创建了一个列表的迭代器，<code>next(iterator)</code>用于获取列表中的下一个元素。迭代器通过不断调用<code>next()</code>方法来遍历集合中的元素。</p>
<h4 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h4><p>我们也可以通过自定义类来实现迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, low, high</span>):</span><br><span class="line">        <span class="variable language_">self</span>.current = low</span><br><span class="line">        <span class="variable language_">self</span>.high = high</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.current &gt; <span class="variable language_">self</span>.high:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.current - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个从0到4的计数器</span></span><br><span class="line">counter = Counter(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> counter:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们自定义了一个<code>Counter</code>类，使其可以作为迭代器使用。<code>__next__()</code>方法返回当前计数，并在超出<code>high</code>值时抛出<code>StopIteration</code>异常。</p>
<h3 id="迭代器的优点"><a href="#迭代器的优点" class="headerlink" title="迭代器的优点"></a>迭代器的优点</h3><ul>
<li><strong>节省内存</strong>：迭代器通常不会一次性加载所有数据，而是逐个生成数据项。因此，它非常适用于大数据集的遍历。</li>
<li><strong>无限序列</strong>：迭代器可以生成无限序列，只要没有达到停止条件，迭代器就会继续生成数据。</li>
</ul>
<h2 id="生成器（Generator）"><a href="#生成器（Generator）" class="headerlink" title="生成器（Generator）"></a>生成器（Generator）</h2><h3 id="生成器的定义"><a href="#生成器的定义" class="headerlink" title="生成器的定义"></a>生成器的定义</h3><p>生成器是使用<code>yield</code>语句的函数。生成器函数与普通函数的区别在于，当执行到<code>yield</code>语句时，函数的执行会暂停，并将当前值返回给调用者。下次调用时，生成器函数从上次暂停的地方继续执行。生成器函数不返回一个值，而是返回一个生成器对象，它实现了迭代器协议，具备 <code>__iter__()</code> 和 <code>__next__()</code> 方法。  </p>
<h3 id="创建生成器"><a href="#创建生成器" class="headerlink" title="创建生成器"></a>创建生成器</h3><p>生成器是通过函数中使用<code>yield</code>关键字来创建的。每次调用生成器的<code>__next__()</code>方法时，函数会从上次停止的地方继续执行。</p>
<h4 id="示例：使用yield创建生成器"><a href="#示例：使用yield创建生成器" class="headerlink" title="示例：使用yield创建生成器"></a>示例：使用<code>yield</code>创建生成器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> n  <span class="comment"># 暂停并返回当前值</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">gen = countdown(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出：5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出：4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出：3</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>countdown()</code>是一个生成器函数，它从<code>n</code>开始倒计时，每次通过<code>yield</code>返回当前的<code>n</code>值。每次调用<code>next()</code>时，生成器从上次暂停的地方继续执行。</p>
<h3 id="生成器的特点"><a href="#生成器的特点" class="headerlink" title="生成器的特点"></a>生成器的特点</h3><ul>
<li><strong>延迟计算</strong>：生成器并不在创建时就生成所有的值，而是每次调用<code>next()</code>时生成一个新值。它仅在需要时才生成下一个值，适合处理大数据集。</li>
<li><strong>内存效率</strong>：由于生成器不会一次性将所有数据加载到内存中，它们非常节省内存。适用于大规模数据处理。</li>
</ul>
<h3 id="生成器与迭代器的关系"><a href="#生成器与迭代器的关系" class="headerlink" title="生成器与迭代器的关系"></a>生成器与迭代器的关系</h3><p>生成器是实现迭代器的一种特殊方式，实际上，生成器就是一种迭代器。它使用<code>yield</code>生成数据，并通过<code>__next__()</code>方法进行遍历。与手动实现的迭代器相比，生成器更简洁、灵活。</p>
<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>除了使用生成器函数，Python还允许通过生成器表达式来创建生成器。这类似于列表推导式，但它返回的是一个生成器，而不是一个列表。</p>
<h3 id="示例：使用生成器表达式"><a href="#示例：使用生成器表达式" class="headerlink" title="示例：使用生成器表达式"></a>示例：使用生成器表达式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gen = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出：0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出：1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出：4</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>(x * x for x in range(5))</code>是一个生成器表达式，它生成了0到4的平方值。与列表推导式不同，生成器表达式不会立即生成所有的值，而是每次请求一个新值时才计算。</p>
<h3 id="生成器表达式的优点"><a href="#生成器表达式的优点" class="headerlink" title="生成器表达式的优点"></a>生成器表达式的优点</h3><ul>
<li><strong>简洁</strong>：生成器表达式提供了一种简洁的方式来创建生成器。</li>
<li><strong>节省内存</strong>：它不会一次性计算并存储所有的值，而是每次请求一个值时才计算。</li>
</ul>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>迭代器是实现了<code>__iter__()</code>和<code>__next__()</code>方法的对象。</li>
<li>可以通过<code>iter()</code>和<code>next()</code>函数来使用。</li>
<li>适用于需要逐步获取数据的场景，节省内存。</li>
</ul>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><ul>
<li>生成器是使用<code>yield</code>的函数。</li>
<li>生成器通过暂停和恢复的机制，按需生成数据。</li>
<li>适用于需要延迟计算和节省内存的场景。</li>
</ul>
<h3 id="生成器与迭代器的关系-1"><a href="#生成器与迭代器的关系-1" class="headerlink" title="生成器与迭代器的关系"></a>生成器与迭代器的关系</h3><ul>
<li>生成器是迭代器的一种特殊实现，生成器函数通过<code>yield</code>返回一个可迭代的对象。</li>
<li>与普通迭代器相比，生成器通常更加简洁且内存效率更高。</li>
</ul>
<hr>
<h1 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h1><h2 id="上下文管理器（Context-Managers）"><a href="#上下文管理器（Context-Managers）" class="headerlink" title="上下文管理器（Context Managers）"></a>上下文管理器（Context Managers）</h2><p>上下文管理器是Python中用于管理资源（如文件、网络连接、数据库连接等）的一种机制。它允许开发者在某个代码块执行之前和之后自动执行特定的操作，如打开资源、释放资源等。上下文管理器通过<code>with</code>语句来使用，它确保在使用完资源后进行必要的清理工作，不论代码块中是否发生异常。</p>
<p>上下文管理器在处理资源时非常有用，尤其在确保资源得到释放时（如文件关闭、数据库连接关闭、锁释放等）。通过使用上下文管理器，我们可以避免写重复的清理代码，并使代码更加简洁和安全。</p>
<h2 id="with语句的基本语法"><a href="#with语句的基本语法" class="headerlink" title="with语句的基本语法"></a><code>with</code>语句的基本语法</h2><p>上下文管理器的核心是<code>with</code>语句，<code>with</code>语句会自动管理代码块的前后资源，确保资源的正确使用与释放。它的基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> context_manager <span class="keyword">as</span> variable:</span><br><span class="line">    <span class="comment"># 执行的代码块</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>context_manager</code>是实现了上下文管理协议的对象。</li>
<li><code>variable</code>是上下文管理器提供的资源，可以在代码块中使用。</li>
</ul>
<h2 id="使用内建的上下文管理器"><a href="#使用内建的上下文管理器" class="headerlink" title="使用内建的上下文管理器"></a>使用内建的上下文管理器</h2><p>Python提供了一些内建的上下文管理器，最常见的就是用于处理文件操作的<code>open()</code>函数，它可以自动管理文件的打开和关闭。</p>
<h3 id="示例：使用with管理文件操作"><a href="#示例：使用with管理文件操作" class="headerlink" title="示例：使用with管理文件操作"></a>示例：使用<code>with</code>管理文件操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;sample.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>open(&quot;sample.txt&quot;, &quot;r&quot;)</code>返回一个上下文管理器对象。<code>with</code>语句确保文件在使用完毕后被正确关闭。即使在<code>read()</code>操作过程中抛出异常，文件也会被正确关闭。</p>
<h3 id="with语句的工作原理"><a href="#with语句的工作原理" class="headerlink" title="with语句的工作原理"></a><code>with</code>语句的工作原理</h3><p>当<code>with</code>语句执行时，Python会执行上下文管理器的<code>__enter__()</code>方法，然后进入代码块。代码块执行完毕后，无论是否发生异常，都会执行上下文管理器的<code>__exit__()</code>方法来进行清理工作。</p>
<h2 id="自定义上下文管理器"><a href="#自定义上下文管理器" class="headerlink" title="自定义上下文管理器"></a>自定义上下文管理器</h2><p>Python允许我们自定义上下文管理器。要创建一个上下文管理器，我们需要实现<code>__enter__()</code>和<code>__exit__()</code>方法。<code>__enter__()</code>方法用于进入上下文管理器的代码块，<code>__exit__()</code>方法用于退出代码块时进行清理工作。</p>
<h3 id="示例：自定义上下文管理器"><a href="#示例：自定义上下文管理器" class="headerlink" title="示例：自定义上下文管理器"></a>示例：自定义上下文管理器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContextManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Entering the context&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>  <span class="comment"># 可以返回任意对象，通常返回`self`</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Exiting the context&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;An exception occurred: <span class="subst">&#123;exc_value&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 如果返回`True`，则不会再抛出异常；如果返回`False`或`None`，异常将继续传播</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MyContextManager() <span class="keyword">as</span> cm:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Inside the context&quot;</span>)</span><br><span class="line">    <span class="comment"># 可以模拟异常来测试异常处理</span></span><br><span class="line">    <span class="comment"># raise ValueError(&quot;An error occurred!&quot;)</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyContextManager</code>类实现了上下文管理器所需的<code>__enter__</code>和<code>__exit__</code>方法：</p>
<ul>
<li><code>__enter__()</code>方法在<code>with</code>语句执行前调用。它通常用于获取资源，并返回一个值供<code>as</code>后面的变量使用。</li>
<li><code>__exit__()</code>方法在<code>with</code>语句执行完毕后调用。它用于处理资源清理。如果在<code>with</code>块内抛出异常，<code>__exit__()</code>方法会捕获到异常信息，并可以选择是否抛出异常。</li>
</ul>
<h3 id="输出：-5"><a href="#输出：-5" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entering the context</span><br><span class="line">Inside the context</span><br><span class="line">Exiting the context</span><br></pre></td></tr></table></figure>

<p>如果你取消注释代码中抛出异常的部分：</p>
<h3 id="输出（带异常）："><a href="#输出（带异常）：" class="headerlink" title="输出（带异常）："></a>输出（带异常）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entering the context</span><br><span class="line">Inside the context</span><br><span class="line">Exiting the context</span><br><span class="line">An exception occurred: An error occurred!</span><br></pre></td></tr></table></figure>

<h3 id="enter-与-exit-的细节"><a href="#enter-与-exit-的细节" class="headerlink" title="__enter__()与__exit__()的细节"></a><code>__enter__()</code>与<code>__exit__()</code>的细节</h3><ul>
<li><code>**__enter__()**</code>：<ul>
<li><code>__enter__()</code>方法在代码块执行之前调用，通常用于初始化资源。</li>
<li>它的返回值可以传递给<code>with</code>语句中的<code>as</code>变量。</li>
</ul>
</li>
<li><code>**__exit__()**</code>：<ul>
<li><code>__exit__()</code>方法在代码块执行结束时调用，无论代码块是否正常结束。如果代码块内有异常抛出，<code>__exit__()</code>会捕获到异常类型、异常值和回溯信息。</li>
<li>如果<code>__exit__()</code>返回<code>True</code>，异常将被抑制，不会传播；如果返回<code>False</code>或<code>None</code>，异常将继续传播。</li>
</ul>
</li>
</ul>
<h2 id="上下文管理器的常见应用"><a href="#上下文管理器的常见应用" class="headerlink" title="上下文管理器的常见应用"></a>上下文管理器的常见应用</h2><h3 id="1-文件操作"><a href="#1-文件操作" class="headerlink" title="1. 文件操作"></a>1. <strong>文件操作</strong></h3><p>文件的打开和关闭是最常见的上下文管理器应用。<code>with</code>语句确保文件在使用完毕后自动关闭，避免遗漏关闭文件的问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>

<h3 id="2-数据库连接"><a href="#2-数据库连接" class="headerlink" title="2. 数据库连接"></a>2. <strong>数据库连接</strong></h3><p>数据库连接也常常需要使用上下文管理器来保证连接在使用完毕后能够自动关闭。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseConnection</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.connection = sqlite3.connect(<span class="string">&quot;example.db&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.connection</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span><br><span class="line">        <span class="variable language_">self</span>.connection.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Database connection closed&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> DatabaseConnection() <span class="keyword">as</span> conn:</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(<span class="string">&quot;SELECT * FROM users&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(cursor.fetchall())</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>DatabaseConnection</code>类是一个自定义的上下文管理器，它确保数据库连接在<code>with</code>语句结束后关闭。</p>
<h3 id="3-锁"><a href="#3-锁" class="headerlink" title="3. 锁"></a>3. <strong>锁</strong></h3><p>在并发编程中，锁常常用来保证线程安全。Python的<code>threading</code>模块提供了<code>Lock</code>类，它本身就是一个上下文管理器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> lock:</span><br><span class="line">    <span class="comment"># 执行需要线程安全的操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Critical section&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过<code>with</code>语句，可以确保锁在<code>with</code>块执行完毕后自动释放，即使发生异常。</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>上下文管理器</strong>是用于管理资源的一种工具，它可以确保资源在使用完毕后被正确地释放。</li>
<li>上下文管理器通过实现<code>__enter__()</code>和<code>__exit__()</code>方法来定义资源的获取和清理。</li>
<li><code>with</code>语句是Python中使用上下文管理器的主要语法，它可以确保资源的正确管理，避免资源泄露。</li>
<li>上下文管理器的应用场景包括文件操作、数据库连接、锁等。</li>
</ul>
<p>通过使用上下文管理器，Python代码更加简洁、清晰，同时能够有效地管理资源，避免忘记清理资源的问题。</p>
<hr>
<h1 id="元编程与反射"><a href="#元编程与反射" class="headerlink" title="元编程与反射"></a>元编程与反射</h1><p>这块内容有些抽象, 不知道具体应用, 以后遇到再说吧~</p>
<h2 id="元编程简介"><a href="#元编程简介" class="headerlink" title="元编程简介"></a>元编程简介</h2><p><strong>元编程</strong>是指编写能够操作、修改、生成或执行其他代码的代码。在Python中，元编程通过动态地创建或修改类、函数、方法等，提供了非常强大的灵活性。元编程的一些常见应用包括动态生成代码、修改类行为、实现插件架构等。</p>
<p>Python中最常见的元编程技术是通过 **元类（Metaclasses）**来实现的。</p>
<h3 id="什么是元类？"><a href="#什么是元类？" class="headerlink" title="什么是元类？"></a>什么是元类？</h3><p>在Python中，<strong>元类</strong>是定义类的类。所有的类都是由元类创建的，而默认情况下，Python的所有类都是由<code>type</code>元类创建的。<strong>普通类</strong>是用来创建<strong>实例对象</strong>的模板。类定义了对象的属性和方法，当我们创建一个类的实例时，就会根据这个类来创建实际的对象。<strong>元类</strong>是用来创建<strong>类</strong>的类。换句话说，元类控制类的创建过程，而普通类控制实例的创建过程。元类定义了类如何被构建，它可以在类的创建过程中修改类的定义，比如自动为类添加方法、修改属性、强制类遵循某些规则等. 简单来说，元类决定了类的创建方式，它可以控制类的创建过程，并允许开发者修改类的定义。</p>
<h4 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述定义的类实际上是由 type 元类创建的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(MyClass))  <span class="comment"># 输出：&lt;class &#x27;type&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>MyClass</code>类是由<code>type</code>元类创建的。每个类都是<code>type</code>类的实例，因此类本身也是对象。</p>
<h3 id="创建自定义元类"><a href="#创建自定义元类" class="headerlink" title="创建自定义元类"></a>创建自定义元类</h3><p>通过自定义元类，可以在类创建时修改类的属性和方法。这为高级功能提供了更大的灵活性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, dct</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Creating class <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, name, bases, dct) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义元类创建类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>(metaclass=MyMeta):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyMeta</code>是一个自定义的元类，它通过<code>__new__()</code>方法打印出类的创建信息。在创建<code>MyClass</code>类时，<code>MyMeta</code>元类会被调用。</p>
<h3 id="元类的应用场景"><a href="#元类的应用场景" class="headerlink" title="元类的应用场景"></a>元类的应用场景</h3><ul>
<li><strong>动态生成类</strong>：根据需求动态生成类。通过元类，可以在程序运行时创建类。</li>
<li><strong>修改类的行为</strong>：可以修改类的方法和属性，甚至为类添加新功能。</li>
<li><strong>实现单例模式</strong>：元类可以确保类只有一个实例，这就是单例模式的实现。</li>
</ul>
<h2 id="反射简介"><a href="#反射简介" class="headerlink" title="反射简介"></a>反射简介</h2><p><strong>反射</strong>是指程序在运行时动态地获取对象的属性、方法，甚至修改它们。通过反射，程序可以访问对象的内部结构，动态地修改对象的状态，甚至调用对象的方法。</p>
<p>在Python中，反射是通过一些内建函数实现的，例如：<code>getattr()</code>、<code>setattr()</code>、<code>hasattr()</code>等。</p>
<h3 id="使用-getattr-、setattr-、hasattr-进行反射"><a href="#使用-getattr-、setattr-、hasattr-进行反射" class="headerlink" title="使用 getattr()、setattr()、hasattr() 进行反射"></a>使用 <code>getattr()</code>、<code>setattr()</code>、<code>hasattr()</code> 进行反射</h3><ul>
<li><code>getattr()</code>：获取对象的属性值。</li>
<li><code>setattr()</code>：设置对象的属性值。</li>
<li><code>hasattr()</code>：检查对象是否有某个属性。</li>
</ul>
<h4 id="示例：使用-getattr-、setattr-和-hasattr"><a href="#示例：使用-getattr-、setattr-和-hasattr" class="headerlink" title="示例：使用 getattr()、setattr() 和 hasattr()"></a>示例：使用 <code>getattr()</code>、<code>setattr()</code> 和 <code>hasattr()</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">obj = MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取属性值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(obj, <span class="string">&#x27;name&#x27;</span>))  <span class="comment"># 输出：Alice</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置属性值</span></span><br><span class="line"><span class="built_in">setattr</span>(obj, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(obj, <span class="string">&#x27;name&#x27;</span>))  <span class="comment"># 输出：Bob</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查属性是否存在</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(obj, <span class="string">&#x27;name&#x27;</span>))  <span class="comment"># 输出：True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(obj, <span class="string">&#x27;age&#x27;</span>))   <span class="comment"># 输出：False</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>getattr(obj, &#39;name&#39;)</code> 用来获取<code>obj</code>对象的<code>name</code>属性。</li>
<li><code>setattr(obj, &#39;name&#39;, &#39;Bob&#39;)</code> 用来设置<code>obj</code>对象的<code>name</code>属性值为<code>Bob</code>。</li>
<li><code>hasattr(obj, &#39;name&#39;)</code> 检查<code>obj</code>是否有<code>name</code>属性。</li>
</ul>
<h3 id="动态调用方法"><a href="#动态调用方法" class="headerlink" title="动态调用方法"></a>动态调用方法</h3><p>反射不仅可以操作属性，还可以动态调用对象的方法。通过<code>getattr()</code>，可以在运行时获取并调用对象的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">obj = MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态调用方法</span></span><br><span class="line">method_name = <span class="string">&#x27;greet&#x27;</span></span><br><span class="line"><span class="built_in">getattr</span>(obj, method_name)(<span class="string">&#x27;Alice&#x27;</span>)  <span class="comment"># 输出：Hello, Alice!</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>getattr(obj, method_name)</code>返回<code>greet</code>方法，并动态调用它。</p>
<h3 id="使用-inspect-模块获取对象的详细信息"><a href="#使用-inspect-模块获取对象的详细信息" class="headerlink" title="使用 inspect 模块获取对象的详细信息"></a>使用 <code>inspect</code> 模块获取对象的详细信息</h3><p>Python的<code>inspect</code>模块提供了一些函数，可以帮助开发者在运行时检查对象的结构、方法和参数等信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">params = inspect.signature(MyClass.greet).parameters</span><br><span class="line"><span class="built_in">print</span>(params)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>inspect.signature()</code>方法获取了<code>greet</code>方法的参数信息，输出的是方法的签名和参数。</p>
<h2 id="元编程与反射的应用场景"><a href="#元编程与反射的应用场景" class="headerlink" title="元编程与反射的应用场景"></a>元编程与反射的应用场景</h2><h3 id="动态生成类和方法"><a href="#动态生成类和方法" class="headerlink" title="动态生成类和方法"></a>动态生成类和方法</h3><p>元编程可以用于根据需求动态生成类和方法。比如，开发一个框架，它需要根据不同的配置动态创建类，或者在运行时根据不同条件生成不同的方法。</p>
<h3 id="动态修改类的行为"><a href="#动态修改类的行为" class="headerlink" title="动态修改类的行为"></a>动态修改类的行为</h3><p>反射使得程序可以在运行时修改类的属性和方法。例如，某些功能需要在运行时调整对象的行为，这时候可以使用反射修改类的属性，甚至为对象添加新的方法。</p>
<h3 id="插件架构"><a href="#插件架构" class="headerlink" title="插件架构"></a>插件架构</h3><p>元编程和反射常用于实现插件架构。在这种架构中，主程序通过反射动态加载插件，而插件不需要在主程序中硬编码。插件可以在运行时被动态加载、卸载或更新。</p>
<h3 id="调试和测试工具"><a href="#调试和测试工具" class="headerlink" title="调试和测试工具"></a>调试和测试工具</h3><p>反射能够帮助调试工具或测试框架检查对象的状态、方法、成员等。例如，测试框架通过反射自动发现并运行测试方法，而不需要显式地列出每个方法的名称。</p>
<hr>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="并发编程简介"><a href="#并发编程简介" class="headerlink" title="并发编程简介"></a>并发编程简介</h2><p><strong>并发编程</strong>是指在程序中同时执行多个任务，以提高程序的效率，充分利用计算机的多核处理能力。并发编程的核心目标是通过并行或并发执行任务，优化程序的性能，尤其是在处理I&#x2F;O密集型或CPU密集型任务时。</p>
<p>Python通过多种方式支持并发编程，最常见的方式是<strong>多线程（Multithreading）</strong>、**多进程（Multiprocessing）<strong><strong>和</strong></strong>异步编程（Asynchronous Programming）**。每种方式有其适用的场景和优势。</p>
<h2 id="多线程（Multithreading）-1"><a href="#多线程（Multithreading）-1" class="headerlink" title="多线程（Multithreading）"></a>多线程（Multithreading）</h2><p>多线程是指在同一个进程中创建多个线程，每个线程执行一个任务。线程之间共享进程的内存空间，因此它们可以更高效地通信，但需要注意线程同步问题。</p>
<h3 id="Python中的线程"><a href="#Python中的线程" class="headerlink" title="Python中的线程"></a>Python中的线程</h3><p>Python通过<code>threading</code>模块支持多线程。虽然Python的全局解释器锁（GIL）限制了多线程在CPU密集型任务中的并行性，但它仍然适用于I&#x2F;O密集型任务。</p>
<h4 id="示例：使用threading模块创建线程"><a href="#示例：使用threading模块创建线程" class="headerlink" title="示例：使用threading模块创建线程"></a>示例：使用<code>threading</code>模块创建线程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Thread <span class="subst">&#123;name&#125;</span> started&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Thread <span class="subst">&#123;name&#125;</span> finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并启动多个线程</span></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=task, args=(i,))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure>

<p>在这个例子中，创建了三个线程，每个线程都执行<code>task</code>函数。<code>join()</code>方法确保主线程在所有子线程完成之前不会退出。</p>
<h3 id="线程的优缺点"><a href="#线程的优缺点" class="headerlink" title="线程的优缺点"></a>线程的优缺点</h3><ul>
<li><strong>优点</strong>：<ul>
<li>适用于I&#x2F;O密集型任务（如文件读写、网络请求等），能够在等待I&#x2F;O操作时并发执行其他任务。</li>
<li>线程之间的通信比进程间通信更简单，因为它们共享内存。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>由于GIL的存在，线程在执行CPU密集型任务时无法充分利用多核CPU。</li>
<li>线程共享内存，容易出现数据竞争和死锁问题。</li>
</ul>
</li>
</ul>
<h2 id="多进程（Multiprocessing）-1"><a href="#多进程（Multiprocessing）-1" class="headerlink" title="多进程（Multiprocessing）"></a>多进程（Multiprocessing）</h2><p>多进程是指创建多个进程来并行执行任务，每个进程都有独立的内存空间和资源。进程间相互独立，因此它们不会像线程那样出现共享内存的问题。</p>
<h3 id="Python中的多进程"><a href="#Python中的多进程" class="headerlink" title="Python中的多进程"></a>Python中的多进程</h3><p>Python通过<code>multiprocessing</code>模块支持多进程。由于每个进程有独立的内存空间，因此多进程可以避免GIL的限制，适用于CPU密集型任务。</p>
<h4 id="示例：使用multiprocessing模块创建进程"><a href="#示例：使用multiprocessing模块创建进程" class="headerlink" title="示例：使用multiprocessing模块创建进程"></a>示例：使用<code>multiprocessing</code>模块创建进程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Process <span class="subst">&#123;name&#125;</span> started&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Process <span class="subst">&#123;name&#125;</span> finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并启动多个进程</span></span><br><span class="line">processes = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    p = multiprocessing.Process(target=task, args=(i,))</span><br><span class="line">    processes.append(p)</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有进程完成</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<p>在这个例子中，创建了三个进程，每个进程执行<code>task</code>函数。进程之间相互独立，因此它们不会影响彼此的内存空间。</p>
<h3 id="多进程的优缺点"><a href="#多进程的优缺点" class="headerlink" title="多进程的优缺点"></a>多进程的优缺点</h3><ul>
<li><strong>优点</strong>：<ul>
<li>可以充分利用多核CPU，适用于CPU密集型任务（如大规模计算、数据处理等）。</li>
<li>进程之间独立，避免了线程共享内存的复杂性。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>进程之间的通信较为复杂，需要使用<code>Queue</code>、<code>Pipe</code>等进程间通信机制。</li>
<li>创建和管理进程的开销比线程大，因此在启动多个进程时需要谨慎。</li>
</ul>
</li>
</ul>
<h2 id="异步编程（Asynchronous-Programming）"><a href="#异步编程（Asynchronous-Programming）" class="headerlink" title="异步编程（Asynchronous Programming）"></a>异步编程（Asynchronous Programming）</h2><p>异步编程是一种不同于传统同步编程的编程方式，它允许程序在等待某些操作（如I&#x2F;O操作）时继续执行其他任务，而无需阻塞程序的执行。Python的<code>asyncio</code>模块提供了异步编程的核心支持。</p>
<h3 id="Python中的异步编程"><a href="#Python中的异步编程" class="headerlink" title="Python中的异步编程"></a>Python中的异步编程</h3><p>Python的<code>asyncio</code>模块使得编写异步代码变得更加容易。通过<code>async</code>和<code>await</code>关键字，开发者可以定义异步函数并执行异步任务。</p>
<h4 id="示例：使用asyncio实现异步编程"><a href="#示例：使用asyncio实现异步编程" class="headerlink" title="示例：使用asyncio实现异步编程"></a>示例：使用<code>asyncio</code>实现异步编程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Task <span class="subst">&#123;name&#125;</span> started&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 模拟I/O操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Task <span class="subst">&#123;name&#125;</span> finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    tasks = [task(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行异步任务</span></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>task</code>是一个异步函数，<code>await asyncio.sleep(2)</code>模拟了一个耗时的I&#x2F;O操作。通过<code>asyncio.gather()</code>可以并发执行多个异步任务。</p>
<h3 id="异步编程的优缺点"><a href="#异步编程的优缺点" class="headerlink" title="异步编程的优缺点"></a>异步编程的优缺点</h3><ul>
<li><strong>优点</strong>：<ul>
<li>适用于I&#x2F;O密集型任务，能够在等待I&#x2F;O操作时执行其他任务，显著提高程序效率。</li>
<li>相比线程和进程，异步编程的开销较小，因为它不需要创建和管理多个线程或进程。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>异步编程的逻辑较为复杂，调试和维护比传统的同步编程更加困难。</li>
<li>仅适用于I&#x2F;O密集型任务，对于CPU密集型任务并不能提高性能。</li>
</ul>
</li>
</ul>
<h2 id="Python中的并发编程模型选择"><a href="#Python中的并发编程模型选择" class="headerlink" title="Python中的并发编程模型选择"></a>Python中的并发编程模型选择</h2><p>在Python中，可以根据任务的性质选择不同的并发编程模型：</p>
<h3 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1. 多线程"></a>1. <strong>多线程</strong></h3><ul>
<li><strong>适用场景</strong>：I&#x2F;O密集型任务，如网络请求、文件读写等。</li>
<li><strong>优点</strong>：线程之间共享内存，通信开销较小。</li>
<li><strong>缺点</strong>：由于GIL的限制，不能有效提高CPU密集型任务的性能。</li>
</ul>
<h3 id="2-多进程"><a href="#2-多进程" class="headerlink" title="2. 多进程"></a>2. <strong>多进程</strong></h3><ul>
<li><strong>适用场景</strong>：CPU密集型任务，如大规模计算、数据处理等。</li>
<li><strong>优点</strong>：可以充分利用多核CPU。</li>
<li><strong>缺点</strong>：进程间通信复杂，创建和管理进程的开销较大。</li>
</ul>
<h3 id="3-异步编程"><a href="#3-异步编程" class="headerlink" title="3. 异步编程"></a>3. <strong>异步编程</strong></h3><ul>
<li><strong>适用场景</strong>：I&#x2F;O密集型任务，尤其是大量并发I&#x2F;O操作的场景。</li>
<li><strong>优点</strong>：无需创建线程或进程，开销较小，适用于大量并发I&#x2F;O操作。</li>
<li><strong>缺点</strong>：调试复杂，代码较难理解和维护。</li>
</ul>
<hr>
<h1 id="单元测试与测试框架"><a href="#单元测试与测试框架" class="headerlink" title="单元测试与测试框架"></a>单元测试与测试框架</h1><hr>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="使用合适的数据结构"><a href="#使用合适的数据结构" class="headerlink" title="使用合适的数据结构"></a>使用合适的数据结构</h2><p>数据结构的选择对性能影响巨大。标准库中的一些内建结构和模块比手动实现更高效。</p>
<h3 id="使用set代替list查找"><a href="#使用set代替list查找" class="headerlink" title="使用set代替list查找"></a>使用<code>set</code>代替<code>list</code>查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line"><span class="keyword">if</span> item <span class="keyword">in</span> my_list: ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line"><span class="keyword">if</span> item <span class="keyword">in</span> my_set: ...</span><br></pre></td></tr></table></figure>

<p>集合（<code>set</code>）的查找是哈希结构，平均时间复杂度是 O(1)，而列表是 O(n)。</p>
<h3 id="使用collections模块"><a href="#使用collections模块" class="headerlink" title="使用collections模块"></a>使用<code>collections</code>模块</h3><ul>
<li><code>deque</code>：双端队列，适合频繁的头尾插入和删除。</li>
<li><code>defaultdict</code>：自动初始化字典值，避免键不存在的判断。</li>
<li><code>Counter</code>：高效地统计元素频次。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">data = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>]</span><br><span class="line">counter = Counter(data)</span><br><span class="line"><span class="built_in">print</span>(counter[<span class="string">&quot;apple&quot;</span>])  <span class="comment"># 输出：2</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="避免不必要的循环和计算"><a href="#避免不必要的循环和计算" class="headerlink" title="避免不必要的循环和计算"></a>避免不必要的循环和计算</h2><h3 id="使用生成式替代显式循环"><a href="#使用生成式替代显式循环" class="headerlink" title="使用生成式替代显式循环"></a>使用生成式替代显式循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    squares.append(i * i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line">squares = [i * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="使用生成器避免内存爆炸"><a href="#使用生成器避免内存爆炸" class="headerlink" title="使用生成器避免内存爆炸"></a>使用生成器避免内存爆炸</h3><p>列表会一次性加载所有元素，占用大量内存。生成器按需生成，节省资源。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差：占用内存</span></span><br><span class="line">nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好：节省内存</span></span><br><span class="line">nums = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="减少全局变量的访问"><a href="#减少全局变量的访问" class="headerlink" title="减少全局变量的访问"></a>减少全局变量的访问</h2><p>函数内部访问局部变量比访问全局变量快，Python 会优先从局部命名空间查找变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        x = GLOBAL_VALUE * i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>():</span><br><span class="line">    local = GLOBAL_VALUE</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        x = local * i</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="内置函数与库优先"><a href="#内置函数与库优先" class="headerlink" title="内置函数与库优先"></a>内置函数与库优先</h2><p>Python 的内置函数是用 C 语言实现的，效率通常比手写循环高。常见函数包括：</p>
<ul>
<li><code>sum()</code></li>
<li><code>max()</code> &#x2F; <code>min()</code></li>
<li><code>sorted()</code></li>
<li><code>map()</code> &#x2F; <code>filter()</code></li>
<li><code>zip()</code> &#x2F; <code>enumerate()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    total += num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line">total = <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="使用itertools进行高效迭代"><a href="#使用itertools进行高效迭代" class="headerlink" title="使用itertools进行高效迭代"></a>使用<code>itertools</code>进行高效迭代</h2><p><code>itertools</code>模块提供了一批高效的迭代工具，支持惰性求值，适合处理大数据流。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取前10个元素，无需生成整个序列</span></span><br><span class="line">result = islice((x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>)), <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="函数缓存"><a href="#函数缓存" class="headerlink" title="函数缓存"></a>函数缓存</h2><p>对重复调用且参数相同的函数可以使用缓存，提高效率。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">128</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><code>@lru_cache</code> 是内置的装饰器，用于自动缓存函数的返回值，避免重复计算。</p>
<hr>
<h2 id="利用多进程与多线程"><a href="#利用多进程与多线程" class="headerlink" title="利用多进程与多线程"></a>利用多进程与多线程</h2><p>在 CPU 密集型任务中使用<strong>多进程</strong>（<code>multiprocessing</code>），在 I&#x2F;O 密集型任务中使用<strong>多线程</strong>（<code>threading</code>）或<strong>异步编程</strong>（<code>asyncio</code>）来提升程序吞吐能力。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Pool(<span class="number">4</span>) <span class="keyword">as</span> p:</span><br><span class="line">    result = p.<span class="built_in">map</span>(work, <span class="built_in">range</span>(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="使用-Cython、Numba-等工具加速计算"><a href="#使用-Cython、Numba-等工具加速计算" class="headerlink" title="使用 Cython、Numba 等工具加速计算"></a>使用 Cython、Numba 等工具加速计算</h2><p>当 Python 本身难以再优化时，可以考虑使用 C 扩展、JIT 编译等方式提高执行速度。</p>
<ul>
<li><code>Cython</code>：将 Python 编译为 C，提高运行速度。</li>
<li><code>Numba</code>：JIT 编译 Python 代码，自动优化数值计算函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"></span><br><span class="line"><span class="meta">@jit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fast_add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="使用合适的文件与数据格式"><a href="#使用合适的文件与数据格式" class="headerlink" title="使用合适的文件与数据格式"></a>使用合适的文件与数据格式</h2><ul>
<li>文本格式（如 CSV）处理慢，适合用作人类可读。</li>
<li>二进制格式（如 <code>pickle</code>、<code>protobuf</code>、<code>parquet</code>）在性能和体积上更优。</li>
<li>大数据处理可使用 <code>pandas</code> 加载高效的数据格式。</li>
</ul>
<hr>
<h2 id="分析工具与性能监控"><a href="#分析工具与性能监控" class="headerlink" title="分析工具与性能监控"></a>分析工具与性能监控</h2><p>优化前，先找到慢的地方。推荐使用以下工具定位性能瓶颈：</p>
<ul>
<li><code>timeit</code>：测试小段代码运行时间。</li>
<li><code>cProfile</code>：分析程序中各函数的耗时。</li>
<li><code>line_profiler</code>：按行查看函数的性能。</li>
</ul>
<hr>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>**闭包（Closure）**是函数式编程中的一个重要概念。简单来说，闭包是指一个函数能够“记住”并访问它定义时的作用域，即使在外部函数已经执行完毕后，内部函数仍然能够访问外部函数的局部变量。</p>
<p>闭包是通过将函数作为返回值返回来实现的。它不仅仅是一个普通的返回函数，而是包含了对外部作用域的引用。</p>
<h3 id="闭包的构成"><a href="#闭包的构成" class="headerlink" title="闭包的构成"></a>闭包的构成</h3><p>一个闭包包含三个部分：</p>
<ol>
<li><strong>外部函数</strong>：闭包是由外部函数创建的。</li>
<li><strong>内部函数</strong>：在外部函数内部定义的函数。</li>
<li><strong>自由变量（Free variables）</strong>：外部函数中的局部变量，内部函数仍能访问它们，称为自由变量。</li>
</ol>
<hr>
<h2 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h2><ul>
<li>内部函数引用了外部函数的局部变量。</li>
<li>外部函数返回了内部函数的引用，使得外部函数的局部变量能“保留”下来。</li>
<li>闭包可以访问外部函数的变量，即使外部函数已经执行结束。</li>
</ul>
<hr>
<h2 id="闭包的示例"><a href="#闭包的示例" class="headerlink" title="闭包的示例"></a>闭包的示例</h2><h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">closure = outer(<span class="number">10</span>)  <span class="comment"># outer(10) 返回的是 inner 函数</span></span><br><span class="line"><span class="built_in">print</span>(closure(<span class="number">5</span>))     <span class="comment"># 输出：15， 10 + 5</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>outer</code> 是外部函数，<code>inner</code> 是内部函数。</li>
<li><code>inner</code> 可以访问外部函数 <code>outer</code> 的参数 <code>x</code>。</li>
<li><code>closure</code> 通过调用 <code>outer(10)</code> 得到 <code>inner</code> 函数的引用，并且保留了 <code>x = 10</code> 这个变量。</li>
</ul>
<hr>
<h2 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h2><h3 id="函数工厂"><a href="#函数工厂" class="headerlink" title="函数工厂"></a>函数工厂</h3><p>闭包可以用来创建函数工厂，即根据不同的输入参数创建不同的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_adder</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">adder</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> adder</span><br><span class="line"></span><br><span class="line">add_5 = make_adder(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(add_5(<span class="number">10</span>))  <span class="comment"># 输出：15</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>make_adder</code> 函数返回一个加法函数 <code>adder</code>，而 <code>adder</code> 会记住 <code>x</code> 的值。<code>add_5</code> 就是一个通过闭包生成的函数，它始终会把 <code>5</code> 加到输入的参数上。</p>
<h3 id="延迟计算"><a href="#延迟计算" class="headerlink" title="延迟计算"></a>延迟计算</h3><p>闭包也可用于延迟计算，能够保留计算所需的环境。</p>
<p><strong>示例：生成一系列延迟计算的函数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_counter</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">counter</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line">counter1 = make_counter()</span><br><span class="line"><span class="built_in">print</span>(counter1())  <span class="comment"># 输出：1</span></span><br><span class="line"><span class="built_in">print</span>(counter1())  <span class="comment"># 输出：2</span></span><br><span class="line"></span><br><span class="line">counter2 = make_counter()</span><br><span class="line"><span class="built_in">print</span>(counter2())  <span class="comment"># 输出：1</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>make_counter</code> 返回一个计数器函数 <code>counter</code>，每次调用 <code>counter</code> 时会增加 <code>count</code> 的值，并且 <code>count</code> 变量通过闭包被保存下来。<code>counter1</code> 和 <code>counter2</code> 是两个独立的计数器，它们互不干扰。</p>
<hr>
<h2 id="闭包与函数式编程"><a href="#闭包与函数式编程" class="headerlink" title="闭包与函数式编程"></a>闭包与函数式编程</h2><p>闭包是函数式编程中的一个重要特性，能够使函数作为返回值返回，并且带有环境信息。这种特性为实现函数工厂、延迟计算、函数式组合等提供了强大的支持。</p>
<p>通过闭包，可以创建高阶函数（接受或返回函数的函数），并且能在不显式传递参数的情况下，保持函数内部的状态。</p>
<hr>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>闭包</strong>是指一个函数能够记住并访问其定义时的作用域，即使外部函数已经执行完毕。</li>
<li>闭包的关键是内部函数对外部函数变量的引用，以及外部函数返回的内部函数。</li>
<li>闭包常用于函数工厂、延迟计算等场景，能提高代码的灵活性和可复用性。</li>
</ul>
<p>通过使用闭包，可以更好地管理状态、提高函数的复用性，并且在构建一些高级功能时，提供更多的灵活性。</p>
<hr>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>Python 的垃圾回收机制是自动管理内存的一种方式，它通过引用计数和循环垃圾回收来确保不再使用的内存得到回收。垃圾回收机制的目的是避免内存泄漏，并帮助开发者更好地管理内存，减少程序中的内存管理负担。</p>
<hr>
<h2 id="引用计数（Reference-Counting）"><a href="#引用计数（Reference-Counting）" class="headerlink" title="引用计数（Reference Counting）"></a>引用计数（Reference Counting）</h2><p>引用计数是 Python 中的基本内存管理机制。每当一个对象被引用时，Python 会将该对象的引用计数加 1；当引用不再指向该对象时，引用计数会减 1。如果一个对象的引用计数变为 0，表示没有任何变量或对象再引用它，Python 会自动回收该对象所占的内存。</p>
<p><strong>引用计数的工作原理</strong></p>
<p>当一个变量或对象引用其他对象时，Python 会为该对象增加引用计数。随着对象的生命周期变化，引用计数会增加或减少。当一个对象的引用计数最终降为 0 时，意味着没有任何引用指向该对象，Python 会自动销毁该对象并回收其占用的内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">a = []  <span class="comment"># 创建一个空列表</span></span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(a))  <span class="comment"># 输出：2，包含a自身和引用它的getrefcount</span></span><br><span class="line"></span><br><span class="line">b = a  <span class="comment"># b 也引用 a</span></span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(a))  <span class="comment"># 输出：3</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>sys.getrefcount(a)</code> 返回的是对象 <code>a</code> 的引用计数。每当有新的变量引用 <code>a</code> 时，引用计数就会增加。</p>
<p><strong>引用计数的局限性</strong></p>
<p>虽然引用计数是一种简单高效的内存管理方式，但它有一个缺点：无法处理<strong>循环引用</strong>。如果两个对象互相引用，且没有其他地方引用它们，它们的引用计数将永远不会为 0，从而导致内存泄漏。</p>
<hr>
<h2 id="循环垃圾回收（Cycle-Garbage-Collection）"><a href="#循环垃圾回收（Cycle-Garbage-Collection）" class="headerlink" title="循环垃圾回收（Cycle Garbage Collection）"></a>循环垃圾回收（Cycle Garbage Collection）</h2><p>为了处理循环引用问题，Python 引入了 <strong>循环垃圾回收机制</strong>。当多个对象相互引用时，它们的引用计数可能永远不为 0，导致它们的内存无法释放。Python 的循环垃圾回收机制会定期检查这些循环引用，并回收不再使用的内存。</p>
<h3 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h3><p>Python 的垃圾回收机制采用了分代收集（Generational Collection）策略。对象根据其生命周期被划分为三代：</p>
<ul>
<li><strong>第一代</strong>：新创建的对象。</li>
<li><strong>第二代</strong>：经过一次或多次垃圾回收后仍然存活的对象。</li>
<li><strong>第三代</strong>：经历多次垃圾回收且依然存活的对象。</li>
</ul>
<p>垃圾回收的主要策略是：新创建的对象会放入第一代，经过一次或多次垃圾回收后，仍然存活的对象会被提升到第二代或第三代。Python 会优先对第一代对象进行回收，因为它们可能更容易被销毁。</p>
<h3 id="循环引用的检测与回收"><a href="#循环引用的检测与回收" class="headerlink" title="循环引用的检测与回收"></a>循环引用的检测与回收</h3><p>Python 的垃圾回收机制会检测到对象之间的循环引用，并在适当的时候回收这些对象。为了优化性能，Python 不会在每次垃圾回收时都检查所有对象，而是采用增量的方式，只在一定条件下检查和回收循环引用。</p>
<hr>
<h2 id="gc-模块"><a href="#gc-模块" class="headerlink" title="gc 模块"></a><code>gc</code> 模块</h2><p>Python 提供了一个名为 <code>gc</code> 的模块，用于控制和调试垃圾回收过程。<code>gc</code> 模块允许开发者手动触发垃圾回收、检查回收状态，并获取内存使用的相关信息。</p>
<p><strong>常用的 <strong><code>**gc**</code></strong> 函数</strong></p>
<ul>
<li><code>**gc.collect()**</code>：手动启动垃圾回收，清除未被引用的对象。</li>
<li><code>**gc.get_count()**</code>：返回当前垃圾回收的计数，显示每代垃圾回收的次数。</li>
<li><code>**gc.set_debug()**</code>：设置垃圾回收的调试输出，用于查看垃圾回收的详细过程。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">gc.collect()  <span class="comment"># 强制启动垃圾回收</span></span><br><span class="line"><span class="built_in">print</span>(gc.get_count())  <span class="comment"># 获取垃圾回收计数</span></span><br></pre></td></tr></table></figure>

<p>通过这些工具，开发者可以在需要时手动控制垃圾回收过程，避免内存泄漏或不必要的资源占用。</p>
<hr>
<h2 id="内存泄漏的防范"><a href="#内存泄漏的防范" class="headerlink" title="内存泄漏的防范"></a>内存泄漏的防范</h2><p>尽管 Python 使用垃圾回收机制来管理内存，但不当的代码使用仍然可能导致内存泄漏。特别是循环引用或未清理的缓存，可能导致对象无法被回收，造成内存泄漏。为防止内存泄漏，可以采取以下措施：</p>
<h3 id="避免循环引用"><a href="#避免循环引用" class="headerlink" title="避免循环引用"></a>避免循环引用</h3><p>尽量避免对象之间互相引用，特别是在复杂的对象之间。使用弱引用（<code>weakref</code>）可以有效防止对象在不需要时仍然占用内存。</p>
<h3 id="显式删除不再需要的引用"><a href="#显式删除不再需要的引用" class="headerlink" title="显式删除不再需要的引用"></a>显式删除不再需要的引用</h3><p>当某个对象不再使用时，可以显式地将其引用设为 <code>None</code> 或使用 <code>del</code> 删除对象，以帮助垃圾回收器更早地回收内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = SomeLargeObject()</span><br><span class="line"><span class="keyword">del</span> a  <span class="comment"># 显式删除引用</span></span><br></pre></td></tr></table></figure>

<h3 id="使用弱引用（weakref）"><a href="#使用弱引用（weakref）" class="headerlink" title="使用弱引用（weakref）"></a>使用弱引用（<code>weakref</code>）</h3><p>通常，当创建一个对象的引用时（例如通过变量或数据结构引用它），Python 会增加该对象的引用计数。当引用计数为零时，Python 的垃圾回收机制会自动销毁该对象。这个过程通常被称为 <strong>强引用</strong>。</p>
<p>而 <strong>弱引用</strong> 与此不同，它不会增加对象的引用计数。因此，如果一个对象仅被弱引用指向，它仍然可以被垃圾回收器销毁，不会因为存在弱引用而延长其生命周期。</p>
<p>在缓存或对象池中，使用弱引用（<code>weakref</code>）可以避免对对象的强引用，确保对象在没有其他引用时能够及时被回收。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">weak_ref = weakref.ref(obj)</span><br><span class="line"><span class="built_in">print</span>(weak_ref())  <span class="comment"># 返回对象本身</span></span><br></pre></td></tr></table></figure>

<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://lyi61pd.github.io">lyi61pd</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://lyi61pd.github.io/2025/04/22/Python/">https://lyi61pd.github.io/2025/04/22/Python/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post-share"><div class="social-share" data-image="/blog_imgs/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">操作系统</div></div><div class="info-2"><div class="info-item-1">操作系统的基本概念什么是操作系统操作系统（Operating System，简称 OS）是管理计算机硬件和软件资源的系统程序，是用户与硬件之间的中介。它负责管理 CPU、内存、磁盘、外设等资源，调度任务的执行，并为应用程序提供统一的接口。 常见的操作系统包括 Linux、Windows、macOS、Android、iOS 等。不同的操作系统在用户体验、系统结构和调度策略上各有差异，但其核心机制大体相似。  操作系统的主要功能进程管理进程是正在运行的程序实例。操作系统负责创建、调度、终止进程，并提供进程间通信（IPC）机制。多进程系统可以并发运行多个任务，提高资源利用率。 内存管理操作系统需要管理所有程序的内存空间，避免冲突，并提供抽象的虚拟地址空间，使得每个程序看似拥有完整的内存。分页、分段、交换空间（Swap）等技术常用于内存管理。 文件系统文件系统是组织和存储数据的结构方式。它定义了文件的命名、权限、目录结构、读写方式等。常见的文件系统包括 FAT32、NTFS、ext4...</div></div></div></a><a class="pagination-related" href="/2025/06/30/Git/" title="Git"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Git</div></div><div class="info-2"><div class="info-item-1">初始化新建仓库直接复制gitlab的，稍微改了点，还是待优化 123456789101112131415161718192021222324252627282930# Git global setupgit config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx&quot;# Create a new repositorygit clone xxxxcd uscangit switch -c maintouch README.mdgit add README.mdgit commit -m &quot;add README&quot;git push -u origin main# Push an existing foldercd existing_foldergit initgit checkout -b maingit remote add origin xxxxxxgit add .git commit -m &quot;Initial...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/blog_imgs/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">lyi61pd</div><div class="author-info-description">Im gonna be the best dragon</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lyi61pd"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E9%9D%9E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">引用与非引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%9D%9E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">Python中的引用类型与非引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%9D%9E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">引用类型与非引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">引用类型（可变类型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">非引用类型（不可变类型）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E3%80%81%E9%9D%9E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.</span> <span class="toc-text">函数传参与引用类型、非引用类型的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82"><span class="toc-number">1.3.1.</span> <span class="toc-text">引用类型传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82"><span class="toc-number">1.3.2.</span> <span class="toc-text">非引用类型传参</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">Python中的类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%B1%BB"><span class="toc-number">2.1.1.</span> <span class="toc-text">定义一个类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%88%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">创建类的实例（对象）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">__init__方法与构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#init-%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">__init__方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#self%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">self参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">2.2.3.</span> <span class="toc-text">类的继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">2.3.</span> <span class="toc-text">类的多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">类的私有属性与方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.5.</span> <span class="toc-text">访问实例的属性的调用顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.</span> <span class="toc-text">拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.1.</span> <span class="toc-text">Python中的拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%88Shallow-Copy%EF%BC%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">浅拷贝（Shallow Copy）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%88Deep-Copy%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">深拷贝（Deep Copy）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">浅拷贝与深拷贝的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.2.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.2.2.</span> <span class="toc-text">深拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.3.</span> <span class="toc-text">拷贝的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">拷贝与对象类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.3.2.</span> <span class="toc-text">对于自定义对象的拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">多线程和多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">Python中的多进程与多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88Multiprocessing%EF%BC%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">多进程（Multiprocessing）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">多进程的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">创建多进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">多进程的优势与劣势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88Multithreading%EF%BC%89"><span class="toc-number">4.1.2.</span> <span class="toc-text">多线程（Multithreading）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">多线程的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">创建多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">多线程的优势与劣势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84GIL%EF%BC%88%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81%EF%BC%89"><span class="toc-number">4.1.3.</span> <span class="toc-text">Python中的GIL（全局解释器锁）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.4.</span> <span class="toc-text">选择多进程还是多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">4.2.</span> <span class="toc-text">进程与线程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">进程间通信（IPC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">4.2.2.</span> <span class="toc-text">线程间通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">5.</span> <span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89-1"><span class="toc-number">5.1.</span> <span class="toc-text">进程间通信（IPC）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">队列（Queue）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%EF%BC%88Pipe%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">管道（Pipe）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88Value-Array%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">共享内存（Value&#x2F;Array）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Value%E8%BF%9B%E8%A1%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E9%80%9A%E4%BF%A1"><span class="toc-number">5.4.1.</span> <span class="toc-text">使用Value进行共享内存通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Array%E8%BF%9B%E8%A1%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E9%80%9A%E4%BF%A1"><span class="toc-number">5.4.2.</span> <span class="toc-text">使用Array进行共享内存通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">5.5.</span> <span class="toc-text">进程间通信的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Lock%E5%90%8C%E6%AD%A5%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.5.1.</span> <span class="toc-text">使用Lock同步进程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-1"><span class="toc-number">6.</span> <span class="toc-text">线程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">6.1.</span> <span class="toc-text">共享内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89-1"><span class="toc-number">6.2.</span> <span class="toc-text">队列（Queue）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%EF%BC%88Event%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">事件（Event）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%EF%BC%88Lock%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">锁（Lock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%EF%BC%88Condition%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">条件（Condition）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text">Lambda表达式的基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.2.</span> <span class="toc-text">Lambda表达式的示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.2.1.</span> <span class="toc-text">最简单的Lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.2.</span> <span class="toc-text">使用Lambda表达式创建简单的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.3.</span> <span class="toc-text">Lambda表达式的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8map-%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8Lambda"><span class="toc-number">7.3.1.</span> <span class="toc-text">在map()函数中使用Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8filter-%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8Lambda"><span class="toc-number">7.3.2.</span> <span class="toc-text">在filter()函数中使用Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8sorted-%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8Lambda"><span class="toc-number">7.3.3.</span> <span class="toc-text">在sorted()函数中使用Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8reduce-%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8Lambda"><span class="toc-number">7.3.4.</span> <span class="toc-text">在reduce()函数中使用Lambda</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">7.4.</span> <span class="toc-text">Lambda表达式与普通函数的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%AE%80%E6%B4%81%E6%80%A7"><span class="toc-number">7.4.1.</span> <span class="toc-text">定义简洁性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E9%99%90%E5%88%B6"><span class="toc-number">7.4.2.</span> <span class="toc-text">功能限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E7%94%A8%E6%80%A7"><span class="toc-number">7.4.3.</span> <span class="toc-text">可重用性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">7.4.4.</span> <span class="toc-text">性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">7.5.</span> <span class="toc-text">Lambda表达式的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">7.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">7.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">7.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">类型注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%EF%BC%88Type-Annotation%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">类型注解（Type Annotation）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.2.1.</span> <span class="toc-text">函数参数的类型注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.2.2.</span> <span class="toc-text">变量的类型注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.2.3.</span> <span class="toc-text">复合类型注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">列表的类型注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.2.3.2.</span> <span class="toc-text">字典的类型注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.2.3.3.</span> <span class="toc-text">元组的类型注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B%EF%BC%88Optional%EF%BC%89"><span class="toc-number">8.2.4.</span> <span class="toc-text">可选类型（Optional）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%88Type-Aliases%EF%BC%89"><span class="toc-number">8.2.5.</span> <span class="toc-text">类型别名（Type Aliases）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88Union%EF%BC%89"><span class="toc-number">8.2.6.</span> <span class="toc-text">联合类型（Union）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E4%B8%8E%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5"><span class="toc-number">8.2.7.</span> <span class="toc-text">类型推导与静态检查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8mypy%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">8.2.7.1.</span> <span class="toc-text">示例：使用mypy进行类型检查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">8.3.</span> <span class="toc-text">类型注解的优势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7"><span class="toc-number">8.3.1.</span> <span class="toc-text">增强代码可读性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F"><span class="toc-number">8.3.2.</span> <span class="toc-text">提高代码质量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87"><span class="toc-number">8.3.3.</span> <span class="toc-text">增加开发效率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">8.4.</span> <span class="toc-text">类型注解的限制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E5%B9%B6%E4%B8%8D%E5%BC%BA%E5%88%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">8.4.1.</span> <span class="toc-text">1. 类型注解并不强制执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7%E4%B8%A7%E5%A4%B1"><span class="toc-number">8.4.2.</span> <span class="toc-text">2. 动态类型语言的灵活性丧失</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">装饰器的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">装饰器的基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">9.2.1.</span> <span class="toc-text">示例：最简单的装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A"><span class="toc-number">9.2.2.</span> <span class="toc-text">输出：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">9.3.</span> <span class="toc-text">装饰器的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%A3%85%E9%A5%B0%E5%99%A8%E7%94%A8%E4%BA%8E%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="toc-number">9.3.1.</span> <span class="toc-text">示例：装饰器用于日志记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A-1"><span class="toc-number">9.3.2.</span> <span class="toc-text">输出：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">9.4.</span> <span class="toc-text">带参数的装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">9.4.1.</span> <span class="toc-text">示例：带参数的装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A-2"><span class="toc-number">9.4.2.</span> <span class="toc-text">输出：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">9.5.</span> <span class="toc-text">装饰器与函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">9.5.1.</span> <span class="toc-text">示例：装饰器与函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A-3"><span class="toc-number">9.5.2.</span> <span class="toc-text">输出：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8"><span class="toc-number">9.6.</span> <span class="toc-text">装饰器的嵌套使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%A4%9A%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">9.6.1.</span> <span class="toc-text">示例：多个装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A-4"><span class="toc-number">9.6.2.</span> <span class="toc-text">输出：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#functools-wraps%EF%BC%9A%E4%BF%9D%E7%95%99%E5%8E%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">9.7.</span> <span class="toc-text">functools.wraps：保留原函数的元数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8functools-wraps"><span class="toc-number">9.7.1.</span> <span class="toc-text">示例：使用functools.wraps</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">9.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">生成器和迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.1.</span> <span class="toc-text">生成器与迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88Iterator%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">迭代器（Iterator）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">10.2.1.</span> <span class="toc-text">迭代器的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.2.2.</span> <span class="toc-text">创建迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8"><span class="toc-number">10.2.2.1.</span> <span class="toc-text">示例：使用迭代器遍历列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.2.2.2.</span> <span class="toc-text">自定义迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">10.2.3.</span> <span class="toc-text">迭代器的优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%88Generator%EF%BC%89"><span class="toc-number">10.3.</span> <span class="toc-text">生成器（Generator）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">10.3.1.</span> <span class="toc-text">生成器的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">10.3.2.</span> <span class="toc-text">创建生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8yield%E5%88%9B%E5%BB%BA%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">10.3.2.1.</span> <span class="toc-text">示例：使用yield创建生成器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">10.3.3.</span> <span class="toc-text">生成器的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">10.3.4.</span> <span class="toc-text">生成器与迭代器的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">10.4.</span> <span class="toc-text">生成器表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">10.4.1.</span> <span class="toc-text">示例：使用生成器表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">10.4.2.</span> <span class="toc-text">生成器表达式的优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">10.5.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.5.1.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">10.5.2.</span> <span class="toc-text">生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB-1"><span class="toc-number">10.5.3.</span> <span class="toc-text">生成器与迭代器的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text">上下文管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%88Context-Managers%EF%BC%89"><span class="toc-number">11.1.</span> <span class="toc-text">上下文管理器（Context Managers）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#with%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">with语句的基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E5%BB%BA%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">11.3.</span> <span class="toc-text">使用内建的上下文管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8with%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">11.3.1.</span> <span class="toc-text">示例：使用with管理文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#with%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">11.3.2.</span> <span class="toc-text">with语句的工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">11.4.</span> <span class="toc-text">自定义上下文管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">11.4.1.</span> <span class="toc-text">示例：自定义上下文管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A-5"><span class="toc-number">11.4.2.</span> <span class="toc-text">输出：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%88%E5%B8%A6%E5%BC%82%E5%B8%B8%EF%BC%89%EF%BC%9A"><span class="toc-number">11.4.3.</span> <span class="toc-text">输出（带异常）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enter-%E4%B8%8E-exit-%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">11.4.4.</span> <span class="toc-text">__enter__()与__exit__()的细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8"><span class="toc-number">11.5.</span> <span class="toc-text">上下文管理器的常见应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">11.5.1.</span> <span class="toc-text">1. 文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5"><span class="toc-number">11.5.2.</span> <span class="toc-text">2. 数据库连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%94%81"><span class="toc-number">11.5.3.</span> <span class="toc-text">3. 锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">11.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="toc-number">12.</span> <span class="toc-text">元编程与反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">12.1.</span> <span class="toc-text">元编程简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E7%B1%BB%EF%BC%9F"><span class="toc-number">12.1.1.</span> <span class="toc-text">什么是元类？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%A6%82%EF%BC%9A"><span class="toc-number">12.1.1.1.</span> <span class="toc-text">例如：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB"><span class="toc-number">12.1.2.</span> <span class="toc-text">创建自定义元类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">12.1.3.</span> <span class="toc-text">元类的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%AE%80%E4%BB%8B"><span class="toc-number">12.2.</span> <span class="toc-text">反射简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-getattr-%E3%80%81setattr-%E3%80%81hasattr-%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%B0%84"><span class="toc-number">12.2.1.</span> <span class="toc-text">使用 getattr()、setattr()、hasattr() 进行反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-getattr-%E3%80%81setattr-%E5%92%8C-hasattr"><span class="toc-number">12.2.1.1.</span> <span class="toc-text">示例：使用 getattr()、setattr() 和 hasattr()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.2.</span> <span class="toc-text">动态调用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-inspect-%E6%A8%A1%E5%9D%97%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="toc-number">12.2.3.</span> <span class="toc-text">使用 inspect 模块获取对象的详细信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">12.3.</span> <span class="toc-text">元编程与反射的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">12.3.1.</span> <span class="toc-text">动态生成类和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E7%B1%BB%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">12.3.2.</span> <span class="toc-text">动态修改类的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">12.3.3.</span> <span class="toc-text">插件架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%92%8C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">12.3.4.</span> <span class="toc-text">调试和测试工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">13.1.</span> <span class="toc-text">并发编程简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88Multithreading%EF%BC%89-1"><span class="toc-number">13.2.</span> <span class="toc-text">多线程（Multithreading）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">13.2.1.</span> <span class="toc-text">Python中的线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8threading%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">13.2.1.1.</span> <span class="toc-text">示例：使用threading模块创建线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">13.2.2.</span> <span class="toc-text">线程的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88Multiprocessing%EF%BC%89-1"><span class="toc-number">13.3.</span> <span class="toc-text">多进程（Multiprocessing）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">13.3.1.</span> <span class="toc-text">Python中的多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8multiprocessing%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">13.3.1.1.</span> <span class="toc-text">示例：使用multiprocessing模块创建进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">13.3.2.</span> <span class="toc-text">多进程的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%88Asynchronous-Programming%EF%BC%89"><span class="toc-number">13.4.</span> <span class="toc-text">异步编程（Asynchronous Programming）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">13.4.1.</span> <span class="toc-text">Python中的异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8asyncio%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">13.4.1.1.</span> <span class="toc-text">示例：使用asyncio实现异步编程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">13.4.2.</span> <span class="toc-text">异步编程的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="toc-number">13.5.</span> <span class="toc-text">Python中的并发编程模型选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">13.5.1.</span> <span class="toc-text">1. 多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">13.5.2.</span> <span class="toc-text">2. 多进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">13.5.3.</span> <span class="toc-text">3. 异步编程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-number">14.</span> <span class="toc-text">单元测试与测试框架</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">15.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">15.1.</span> <span class="toc-text">使用合适的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8set%E4%BB%A3%E6%9B%BFlist%E6%9F%A5%E6%89%BE"><span class="toc-number">15.1.1.</span> <span class="toc-text">使用set代替list查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8collections%E6%A8%A1%E5%9D%97"><span class="toc-number">15.1.2.</span> <span class="toc-text">使用collections模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%92%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">15.2.</span> <span class="toc-text">避免不必要的循环和计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%BC%8F%E6%9B%BF%E4%BB%A3%E6%98%BE%E5%BC%8F%E5%BE%AA%E7%8E%AF"><span class="toc-number">15.2.1.</span> <span class="toc-text">使用生成式替代显式循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E7%88%86%E7%82%B8"><span class="toc-number">15.2.2.</span> <span class="toc-text">使用生成器避免内存爆炸</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">15.3.</span> <span class="toc-text">减少全局变量的访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E4%B8%8E%E5%BA%93%E4%BC%98%E5%85%88"><span class="toc-number">15.4.</span> <span class="toc-text">内置函数与库优先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8itertools%E8%BF%9B%E8%A1%8C%E9%AB%98%E6%95%88%E8%BF%AD%E4%BB%A3"><span class="toc-number">15.5.</span> <span class="toc-text">使用itertools进行高效迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98"><span class="toc-number">15.6.</span> <span class="toc-text">函数缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">15.7.</span> <span class="toc-text">利用多进程与多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Cython%E3%80%81Numba-%E7%AD%89%E5%B7%A5%E5%85%B7%E5%8A%A0%E9%80%9F%E8%AE%A1%E7%AE%97"><span class="toc-number">15.8.</span> <span class="toc-text">使用 Cython、Numba 等工具加速计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">15.9.</span> <span class="toc-text">使用合适的文件与数据格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7"><span class="toc-number">15.10.</span> <span class="toc-text">分析工具与性能监控</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">16.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">16.1.</span> <span class="toc-text">闭包的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">16.1.1.</span> <span class="toc-text">闭包的构成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">16.2.</span> <span class="toc-text">闭包的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">16.3.</span> <span class="toc-text">闭包的示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B"><span class="toc-number">16.3.1.</span> <span class="toc-text">基本示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">16.4.</span> <span class="toc-text">闭包的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B7%A5%E5%8E%82"><span class="toc-number">16.4.1.</span> <span class="toc-text">函数工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E8%AE%A1%E7%AE%97"><span class="toc-number">16.4.2.</span> <span class="toc-text">延迟计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">16.5.</span> <span class="toc-text">闭包与函数式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">16.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">17.</span> <span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%88Reference-Counting%EF%BC%89"><span class="toc-number">17.1.</span> <span class="toc-text">引用计数（Reference Counting）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88Cycle-Garbage-Collection%EF%BC%89"><span class="toc-number">17.2.</span> <span class="toc-text">循环垃圾回收（Cycle Garbage Collection）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">17.2.1.</span> <span class="toc-text">分代垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">17.2.2.</span> <span class="toc-text">循环引用的检测与回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-%E6%A8%A1%E5%9D%97"><span class="toc-number">17.3.</span> <span class="toc-text">gc 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E9%98%B2%E8%8C%83"><span class="toc-number">17.4.</span> <span class="toc-text">内存泄漏的防范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">17.4.1.</span> <span class="toc-text">避免循环引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%88%A0%E9%99%A4%E4%B8%8D%E5%86%8D%E9%9C%80%E8%A6%81%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">17.4.2.</span> <span class="toc-text">显式删除不再需要的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88weakref%EF%BC%89"><span class="toc-number">17.4.3.</span> <span class="toc-text">使用弱引用（weakref）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/30/Sliver/" title="Sliver">Sliver</a><time datetime="2025-07-30T00:00:00.000Z" title="Created 2025-07-30 00:00:00">2025-07-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/07/%E6%B1%87%E7%BC%96/" title="汇编">汇编</a><time datetime="2025-07-07T00:00:00.000Z" title="Created 2025-07-07 00:00:00">2025-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/30/Git/" title="Git">Git</a><time datetime="2025-06-30T00:00:00.000Z" title="Created 2025-06-30 00:00:00">2025-06-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/Python/" title="Python">Python</a><time datetime="2025-04-22T00:00:00.000Z" title="Created 2025-04-22 00:00:00">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/17/CVE-2021-3156/" title="CVE-2021-3156">CVE-2021-3156</a><time datetime="2025-04-17T00:00:00.000Z" title="Created 2025-04-17 00:00:00">2025-04-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/blog_imgs/banner.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By lyi61pd</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>
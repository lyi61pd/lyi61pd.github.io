<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C2 | lyi61pd</title><meta name="author" content="lyi61pd"><meta name="copyright" content="lyi61pd"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C2基础什么是 C2 框架C2（Command &amp; Control）框架是攻击链中控制阶段的核心部分，用于红队与植入目标主机的木马（Agent&#x2F;Beacon）之间建立通信，执行命令、收集信息、上传下载文件、做横向移动等等。C2 框架的本质是一套包含控制端（Server）与客户端（Payload&#x2F;Beacon）的通信系统。  主流 C2 框架架构设计拆解Cobalt St">
<meta property="og:type" content="article">
<meta property="og:title" content="C2">
<meta property="og:url" content="https://lyi61pd.github.io/2025/04/08/C2/">
<meta property="og:site_name" content="lyi61pd">
<meta property="og:description" content="C2基础什么是 C2 框架C2（Command &amp; Control）框架是攻击链中控制阶段的核心部分，用于红队与植入目标主机的木马（Agent&#x2F;Beacon）之间建立通信，执行命令、收集信息、上传下载文件、做横向移动等等。C2 框架的本质是一套包含控制端（Server）与客户端（Payload&#x2F;Beacon）的通信系统。  主流 C2 框架架构设计拆解Cobalt St">
<meta property="og:locale">
<meta property="og:image" content="https://lyi61pd.github.io/blog_imgs/avatar.png">
<meta property="article:published_time" content="2025-04-08T00:00:00.000Z">
<meta property="article:modified_time" content="2025-07-30T03:40:55.099Z">
<meta property="article:author" content="lyi61pd">
<meta property="article:tag" content="C2">
<meta property="article:tag" content="安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lyi61pd.github.io/blog_imgs/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C2",
  "url": "https://lyi61pd.github.io/2025/04/08/C2/",
  "image": "https://lyi61pd.github.io/blog_imgs/avatar.png",
  "datePublished": "2025-04-08T00:00:00.000Z",
  "dateModified": "2025-07-30T03:40:55.099Z",
  "author": [
    {
      "@type": "Person",
      "name": "lyi61pd",
      "url": "https://lyi61pd.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/blog_imgs/avatar.png"><link rel="canonical" href="https://lyi61pd.github.io/2025/04/08/C2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C2',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="lyi61pd" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/blog_imgs/banner.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">lyi61pd</span></a><a class="nav-page-title" href="/"><span class="site-name">C2</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div></div></nav><div id="post-info"><h1 class="post-title">C2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-04-08T00:00:00.000Z" title="Created 2025-04-08 00:00:00">2025-04-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-30T03:40:55.099Z" title="Updated 2025-07-30 03:40:55">2025-07-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C2基础"><a href="#C2基础" class="headerlink" title="C2基础"></a>C2基础</h1><h2 id="什么是-C2-框架"><a href="#什么是-C2-框架" class="headerlink" title="什么是 C2 框架"></a>什么是 C2 框架</h2><p>C2（Command &amp; Control）框架是攻击链中控制阶段的核心部分，用于红队与植入目标主机的木马（Agent&#x2F;Beacon）之间建立通信，执行命令、收集信息、上传下载文件、做横向移动等等。C2 框架的本质是一套包含控制端（Server）与客户端（Payload&#x2F;Beacon）的通信系统。</p>
<hr>
<h2 id="主流-C2-框架架构设计拆解"><a href="#主流-C2-框架架构设计拆解" class="headerlink" title="主流 C2 框架架构设计拆解"></a>主流 C2 框架架构设计拆解</h2><h3 id="Cobalt-Strike"><a href="#Cobalt-Strike" class="headerlink" title="Cobalt Strike"></a>Cobalt Strike</h3><p><strong>结构组成：</strong></p>
<ul>
<li><strong>Team Server</strong>：C2 控制端，负责所有 Beacon 的统一管理。</li>
<li><strong>Beacon</strong>：客户端的植入载荷，支持多种通信方式（HTTP、HTTPS、DNS、SMB 等）。</li>
<li><strong>Aggressor Script</strong>：脚本引擎，支持行为自动化。</li>
<li><strong>Client GUI</strong>：操作端，用于管理和执行命令。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>Beacon 模块化强，通信协议支持自定义混淆。</li>
<li>强大的内存马管理与无文件攻击能力。</li>
<li>配合 Malleable C2 支持流量伪装成任意合法 Web 通信。</li>
</ul>
<h3 id="Sliver"><a href="#Sliver" class="headerlink" title="Sliver"></a>Sliver</h3><p><strong>结构组成：</strong></p>
<ul>
<li><strong>Server（sliver-server）</strong>：核心服务端，gRPC + TLS 通信。</li>
<li><strong>Client（sliver-client）</strong>：CLI 或 Web UI，操作指令中心。</li>
<li><strong>Implants（sliver implants）</strong>：客户端植入程序，支持多平台（Windows&#x2F;Linux&#x2F;macOS）。</li>
<li><strong>Transport</strong>：支持多协议通信（HTTP&#x2F;HTTPS、DNS、MTLS、Wireguard）。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>开源，Go 编写，便于二次开发。</li>
<li>支持多种 listener&#x2F;transport，灵活性强。</li>
<li>支持反射 DLL 注入、BOF 执行（内存模块化执行）。</li>
<li>强大的 OPSEC 特性，比如动态切换通信信道。</li>
</ul>
<h3 id="Metasploit-Framework"><a href="#Metasploit-Framework" class="headerlink" title="Metasploit Framework"></a>Metasploit Framework</h3><p><strong>结构组成：</strong></p>
<ul>
<li><strong>msfconsole</strong>：主控台，命令行交互中心。</li>
<li><strong>exploit&#x2F;payload 模块</strong>：负责漏洞利用与载荷投递。</li>
<li><strong>handler（multi&#x2F;handler）</strong>：监听器，用来接收回连。</li>
<li><strong>Meterpreter</strong>：高度模块化的反向连接 shell。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>经典老牌，模块最全，生态强大。</li>
<li>Meterpreter 支持脚本、插件、内存加载模块。</li>
<li>强大但略显笨重，不如 Cobalt Strike 那么轻巧隐蔽。</li>
</ul>
<hr>
<h2 id="常见功能模块对比"><a href="#常见功能模块对比" class="headerlink" title="常见功能模块对比"></a>常见功能模块对比</h2><table>
<thead>
<tr>
<th>功能模块</th>
<th>Cobalt Strike</th>
<th>Sliver</th>
<th>Metasploit</th>
</tr>
</thead>
<tbody><tr>
<td>多协议通信</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>模块热插拔</td>
<td>强</td>
<td>中</td>
<td>弱（Meterpreter 限）</td>
</tr>
<tr>
<td>内存执行</td>
<td>强（BOF）</td>
<td>强（BOF）</td>
<td>中</td>
</tr>
<tr>
<td>插件扩展性</td>
<td>Aggressor 脚本</td>
<td>自定义模块</td>
<td>Ruby 模块化</td>
</tr>
<tr>
<td>操作系统支持</td>
<td>Windows 为主</td>
<td>Win&#x2F;Linux&#x2F;macOS</td>
<td>Win&#x2F;Linux</td>
</tr>
<tr>
<td>UI</td>
<td>图形界面</td>
<td>CLI&#x2F;Web UI</td>
<td>CLI</td>
</tr>
<tr>
<td>流量混淆</td>
<td>Malleable C2</td>
<td>支持多种伪装方式</td>
<td>基础混淆</td>
</tr>
</tbody></table>
<hr>
<h2 id="常见问题理解"><a href="#常见问题理解" class="headerlink" title="常见问题理解"></a>常见问题理解</h2><h3 id="为什么-C2-通信协议多样化重要？"><a href="#为什么-C2-通信协议多样化重要？" class="headerlink" title="为什么 C2 通信协议多样化重要？"></a>为什么 C2 通信协议多样化重要？</h3><p>不同的网络环境下，有的端口封闭、有的协议被 DPI 检测，通信多样化能提高植入后的存活率和隐蔽性。</p>
<h3 id="什么是-BOF（Beacon-Object-File）？"><a href="#什么是-BOF（Beacon-Object-File）？" class="headerlink" title="什么是 BOF（Beacon Object File）？"></a>什么是 BOF（Beacon Object File）？</h3><p>BOF 是 Cobalt Strike 引入的一种运行内存模块的小型 C 语言对象文件，可以在 Beacon 中直接运行，无需生成 EXE 或 DLL，从而提升隐蔽性。Sliver 也支持类似机制。</p>
<h3 id="如何理解“无文件攻击”？"><a href="#如何理解“无文件攻击”？" class="headerlink" title="如何理解“无文件攻击”？"></a>如何理解“无文件攻击”？</h3><p>无文件攻击指的是不在硬盘落地任何可执行文件，所有操作都在内存中完成（例如通过 PowerShell、Reflective DLL Injection、BOF 等方式），这可以绕过大部分杀软的文件监控策略。</p>
<h3 id="这些框架能扩展吗？"><a href="#这些框架能扩展吗？" class="headerlink" title="这些框架能扩展吗？"></a>这些框架能扩展吗？</h3><ul>
<li>Cobalt Strike 的 Aggressor Script 可以写自动化逻辑、钓鱼剧本等。</li>
<li>Sliver 本身就是开源的，开发者可以基于其 gRPC 接口写出新模块或整合其他工具。</li>
<li>Metasploit 框架最容易写模块，自带模板功能，开发周期短。</li>
</ul>
<hr>
<h2 id="红队研发该如何深入学习这些框架？"><a href="#红队研发该如何深入学习这些框架？" class="headerlink" title="红队研发该如何深入学习这些框架？"></a>红队研发该如何深入学习这些框架？</h2><ol>
<li><strong>实操为主</strong>：搭环境，打靶场，不懂的功能就翻官方文档和社区。</li>
<li><strong>读源码&#x2F;脚本</strong>：<ul>
<li>Sliver 是 Go 写的，可以研究通信和 implant 架构。</li>
<li>Aggressor Script 学会后能帮你自动化红队很多流程。</li>
</ul>
</li>
<li><strong>看流量包分析通信协议</strong>：理解通信包结构对规避检测很有帮助。</li>
<li><strong>做开发小模块</strong>：比如给 Sliver 增加一个新的 transport，或者给 Meterpreter 写一个提权模块。</li>
</ol>
<h1 id="Cobalt-Strike-1"><a href="#Cobalt-Strike-1" class="headerlink" title="Cobalt Strike"></a>Cobalt Strike</h1><p>好嘞，那我们从 Cobalt Strike 开始拆，一步步搞清楚它的整体架构、核心组件、通信机制、扩展能力还有一些常见的玩法。这玩意虽然闭源，但文档详细、生态成熟，基本是红队的标配了。</p>
<hr>
<h2 id="Cobalt-Strike-架构核心理解"><a href="#Cobalt-Strike-架构核心理解" class="headerlink" title="Cobalt Strike 架构核心理解"></a>Cobalt Strike 架构核心理解</h2><p>Cobalt Strike 整体架构是经典的 C2 结构，分为控制端（Team Server）和被控端（Beacon），中间通过 Listener 建立通信通道。可以简单理解为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CS Client GUI] → [Team Server] ←→ [Beacon]</span><br></pre></td></tr></table></figure>

<h3 id="1-Team-Server（服务端）"><a href="#1-Team-Server（服务端）" class="headerlink" title="1. Team Server（服务端）"></a>1. Team Server（服务端）</h3><ul>
<li>所有 Beacon 的连接都汇聚到这里。</li>
<li>接收 GUI 发来的操作命令，下发给 Beacon。</li>
<li>支持多个 listener，可用不同协议监听不同 implant。</li>
<li>支持操作记录、会话管理、任务队列、证书伪造等功能。</li>
</ul>
<p>启动方式通常是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./teamserver &lt;公网IP&gt; &lt;密码&gt;</span><br></pre></td></tr></table></figure>

<p>TeamServer 是服务端大脑，很多 hook 和扩展逻辑其实都要和它打交道。</p>
<hr>
<h3 id="2-Beacon（客户端-植入端）"><a href="#2-Beacon（客户端-植入端）" class="headerlink" title="2. Beacon（客户端&#x2F;植入端）"></a>2. Beacon（客户端&#x2F;植入端）</h3><p>Beacon 是攻击者植入目标系统中的主力载荷，是 Cobalt Strike 的核心组件之一。它的设计非常灵活，支持多种执行方式和通信协议。</p>
<p><strong>支持的通信方式：</strong></p>
<ul>
<li><code>HTTP</code> &#x2F; <code>HTTPS</code>：常见 web 通道，配合 Malleable C2 做流量伪装。</li>
<li><code>DNS</code>：低速但高隐蔽，适合静默场景。</li>
<li><code>SMB</code>：横向移动常用，内网通信，免出网。</li>
<li><code>TCP</code> &#x2F; <code>Named Pipe</code>：定制场景用得多。</li>
</ul>
<p><strong>Beacon 的通信机制：</strong></p>
<ul>
<li>默认是“轮询式通信”：<ul>
<li>Beacon 每隔一段时间（默认 60s）主动回连 Team Server。</li>
<li>这个时间间隔（sleep）和 jitter（抖动）可以配置。</li>
</ul>
</li>
<li>通信全程加密（SSL&#x2F;TLS），可通过 Malleable Profile 自定义。</li>
</ul>
<hr>
<h3 id="3-Listener（监听器）"><a href="#3-Listener（监听器）" class="headerlink" title="3. Listener（监听器）"></a>3. Listener（监听器）</h3><p>Listener 是在 Team Server 上开的一种“通信协议通道”，Beacon 会回连到这个 listener。</p>
<p>你可以配置不同协议的 listener，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Listener: HTTPS</span><br><span class="line">Payload: windows/beacon_https/reverse_https</span><br><span class="line">Host: https://c2.example.com</span><br></pre></td></tr></table></figure>

<p>Listener 是一个非常灵活的点，它支持用同一 Team Server 管多个 Beacon 会话，分别回连到不同端口、协议、路径、伪装页面。</p>
<hr>
<h2 id="Malleable-C2：伪装大师"><a href="#Malleable-C2：伪装大师" class="headerlink" title="Malleable C2：伪装大师"></a>Malleable C2：伪装大师</h2><p>这是 Cobalt Strike 最大的核心卖点之一。</p>
<p>它允许你自定义 C2 流量的 HTTP 请求&#x2F;响应外观，能伪装成合法网站（如微软更新、CDN 等），极大地提升流量隐蔽性。</p>
<p><strong>Malleable C2 配置结构：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> useragent <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&quot;</span>;</span><br><span class="line">http-get &#123;</span><br><span class="line">  <span class="built_in">set</span> uri <span class="string">&quot;/api/status&quot;</span>;</span><br><span class="line">  client &#123;</span><br><span class="line">    header <span class="string">&quot;Accept&quot;</span> <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  server &#123;</span><br><span class="line">    output &#123;</span><br><span class="line">      base64;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cobalt Strike 本身提供了大量的 Malleable C2 profile 示例，比如 mimicking GitHub、Google、Microsoft 等常见服务。</p>
<hr>
<h2 id="Aggressor-Script：自动化和扩展利器"><a href="#Aggressor-Script：自动化和扩展利器" class="headerlink" title="Aggressor Script：自动化和扩展利器"></a>Aggressor Script：自动化和扩展利器</h2><p>Aggressor Script 是基于 JavaScript-like 的脚本语言，用于编写自动化流程和 UI 交互功能。</p>
<p><strong>功能包括：</strong></p>
<ul>
<li>自动生成 phishing 邮件、payload。</li>
<li>会话上线后自动执行命令。</li>
<li>自定义菜单、界面组件。</li>
<li>和外部工具联动（如 C2lint、Threat Intel）。</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on beacon_initial &#123;</span><br><span class="line">  <span class="title function_">binput</span>($1, <span class="string">&quot;whoami\n&quot;</span>);</span><br><span class="line">  <span class="title function_">binput</span>($1, <span class="string">&quot;net user\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个脚本会在 beacon 上线时自动执行两个命令。</p>
<hr>
<h2 id="Cobalt-Strike-的一些经典功能模块"><a href="#Cobalt-Strike-的一些经典功能模块" class="headerlink" title="Cobalt Strike 的一些经典功能模块"></a>Cobalt Strike 的一些经典功能模块</h2><ul>
<li><strong>攻击载荷生成（Payload Generator）</strong>：<ul>
<li>EXE、DLL、PS1、SCT、HTA、Java、Shellcode 全家桶支持。</li>
<li>可通过 Artifact Kit 自定义绕杀签名。</li>
</ul>
</li>
<li><strong>提权（Privilege Escalation）</strong>：<ul>
<li>UAC Bypass、令牌劫持、SeImpersonate 工具集成。</li>
</ul>
</li>
<li><strong>横向移动（Lateral Movement）</strong>：<ul>
<li>PsExec、WMI、WinRM、SMB Beacon 派发。</li>
</ul>
</li>
<li><strong>会话管理</strong>：<ul>
<li>Beacon 可以与其他 Beacon 建立 SMB 通道（类似链式代理）。</li>
<li>也支持在多 TeamServer 之间跳转（多级代理）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="常见问题答疑"><a href="#常见问题答疑" class="headerlink" title="常见问题答疑"></a>常见问题答疑</h2><h3 id="Beacon-会话为什么看起来“断断续续”？"><a href="#Beacon-会话为什么看起来“断断续续”？" class="headerlink" title="Beacon 会话为什么看起来“断断续续”？"></a>Beacon 会话为什么看起来“断断续续”？</h3><p>因为默认是轮询通信（sleep 模式），不是实时连接。需要理解 <code>sleep</code> 和 <code>jitter</code> 对通信行为的影响。可以通过 <code>sleep 0</code> 设置为实时响应。</p>
<h3 id="如何提升-Beacon-隐蔽性？"><a href="#如何提升-Beacon-隐蔽性？" class="headerlink" title="如何提升 Beacon 隐蔽性？"></a>如何提升 Beacon 隐蔽性？</h3><ul>
<li>使用 HTTPS 或 DNS 通信；</li>
<li>自定义 Malleable C2 Profile；</li>
<li>Beacon Payload 用 shellcode loader 包裹，绕过查杀；</li>
<li>配合睡眠混淆（sleep_mask）模块进行内存隐藏。</li>
</ul>
<h3 id="如何使用-BOF-模块？"><a href="#如何使用-BOF-模块？" class="headerlink" title="如何使用 BOF 模块？"></a>如何使用 BOF 模块？</h3><p>BOF（Beacon Object File）是 Cobalt Strike 新版支持的内存模块加载方式，类似动态链接库，在 Beacon 中加载执行但不会落地。</p>
<p>执行方式类似：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bof mymodule.o arg1 arg2</span><br></pre></td></tr></table></figure>

<p>BOF 用 C 写，编译成 COFF 文件。</p>
<hr>
<p>如果你接下来想动手搭个实验环境，或者深入看看 Beacon 的 payload 是怎么生效的，我可以接着带你拆 payload 结构或者讲讲 bypass AV&#x2F;EDR 的套路。你想先搞哪个？</p>
<h1 id="Aggressor-Script"><a href="#Aggressor-Script" class="headerlink" title="Aggressor Script"></a><strong>Aggressor Script</strong></h1><p>Aggressor Script 是 Cobalt Strike 内置的一套脚本语言，用来 <strong>扩展 Cobalt Strike 的功能、实现自动化操作、增强交互性</strong>。它是基于 JavaScript 的语法风格，但专门为红队场景定制了一套 API，可以直接操作 Beacon、界面、事件钩子等。</p>
<p>简单来说，<strong>它就是给 Cobalt Strike 加外挂的方式</strong>，很多高级玩法都离不开它，比如：</p>
<ul>
<li>Beacon 上线自动执行命令</li>
<li>自定义右键菜单</li>
<li>监听某个事件触发自定义行为</li>
<li>与外部工具联动（Web API、自动打点、图标美化…）</li>
</ul>
<hr>
<h2 id="Aggressor-Script-能干啥？"><a href="#Aggressor-Script-能干啥？" class="headerlink" title="Aggressor Script 能干啥？"></a>Aggressor Script 能干啥？</h2><p>我按功能分类列一下，让你有个整体感觉。</p>
<h3 id="1-自动响应事件（事件驱动）"><a href="#1-自动响应事件（事件驱动）" class="headerlink" title="1. 自动响应事件（事件驱动）"></a>1. 自动响应事件（事件驱动）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on beacon_initial &#123;</span><br><span class="line">  <span class="title function_">binput</span>($1, <span class="string">&quot;whoami\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Beacon 刚上线时，自动执行 <code>whoami</code> 命令。</p>
<h3 id="2-扩展菜单-UI"><a href="#2-扩展菜单-UI" class="headerlink" title="2. 扩展菜单 &#x2F; UI"></a>2. 扩展菜单 &#x2F; UI</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">popup beacon_top &#123;</span><br><span class="line">  item <span class="string">&quot;列出用户&quot;</span> &#123;</span><br><span class="line">    <span class="title function_">binput</span>($1, <span class="string">&quot;net user\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Beacon 右键菜单中加一项“列出用户”，点一下就发送命令。</p>
<h3 id="3-自定义函数-模块化脚本"><a href="#3-自定义函数-模块化脚本" class="headerlink" title="3. 自定义函数 &#x2F; 模块化脚本"></a>3. 自定义函数 &#x2F; 模块化脚本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sub say_hello &#123;</span><br><span class="line">  <span class="title function_">println</span>(<span class="string">&quot;Hello, Aggressor!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以封装一些重复逻辑，形成工具包式结构。</p>
<h3 id="4-自动生成钓鱼文件、Payload-载荷"><a href="#4-自动生成钓鱼文件、Payload-载荷" class="headerlink" title="4. 自动生成钓鱼文件、Payload 载荷"></a>4. 自动生成钓鱼文件、Payload 载荷</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on ready &#123;</span><br><span class="line">  <span class="title function_">artifact</span>(<span class="string">&quot;windows/beacon_http/reverse_http&quot;</span>, <span class="string">&quot;exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动后自动生成一个载荷文件。</p>
<h3 id="5-网络联动-REST-API-调用"><a href="#5-网络联动-REST-API-调用" class="headerlink" title="5. 网络联动 &#x2F; REST API 调用"></a>5. 网络联动 &#x2F; REST API 调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">local</span>(<span class="string">&#x27;$res&#x27;</span>);</span><br><span class="line">$res = <span class="title function_">http</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://127.0.0.1/api/status&quot;</span>);</span><br><span class="line"><span class="title function_">println</span>(<span class="string">&quot;Status: $res&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以向外部系统发请求，比如联动监控平台、调度框架等。</p>
<hr>
<h2 id="常用函数-命令速查（选几个经典的）"><a href="#常用函数-命令速查（选几个经典的）" class="headerlink" title="常用函数&#x2F;命令速查（选几个经典的）"></a>常用函数&#x2F;命令速查（选几个经典的）</h2><table>
<thead>
<tr>
<th>函数名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>binput()</code></td>
<td>向 Beacon 会话发命令</td>
</tr>
<tr>
<td><code>beacons()</code></td>
<td>获取当前所有 beacon 会话列表</td>
</tr>
<tr>
<td><code>println()</code></td>
<td>输出调试信息到控制台</td>
</tr>
<tr>
<td><code>http()</code></td>
<td>发起 HTTP 请求</td>
</tr>
<tr>
<td><code>popup</code></td>
<td>自定义右键菜单</td>
</tr>
<tr>
<td><code>artifact()</code></td>
<td>自动生成 Payload 文件</td>
</tr>
<tr>
<td><code>open</code></td>
<td>弹出输入框&#x2F;对话框</td>
</tr>
<tr>
<td><code>dialog_text</code></td>
<td>自定义图形输入对话框</td>
</tr>
</tbody></table>
<hr>
<h2 id="Aggressor-Script-编写-加载"><a href="#Aggressor-Script-编写-加载" class="headerlink" title="Aggressor Script 编写&amp;加载"></a>Aggressor Script 编写&amp;加载</h2><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><p>以 <code>.cna</code> 为后缀名（Cobalt Strike Native Aggressor）</p>
<p>例如：<code>autorun.cna</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on beacon_initial &#123;</span><br><span class="line">  <span class="title function_">println</span>(<span class="string">&quot;Beacon上线啦！&quot;</span>);</span><br><span class="line">  <span class="title function_">binput</span>($1, <span class="string">&quot;whoami\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h3><p>在 GUI 的 <strong>Cobalt Strike → Scripts</strong> 菜单中点击 Load，选中你的 <code>.cna</code> 脚本即可。</p>
<p>也可以用命令行加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cobaltstrike.client -&gt; Scripts -&gt; Load -&gt; autorun.cna</span><br></pre></td></tr></table></figure>



<h1 id="Beacon-Stager-Stage-Listener"><a href="#Beacon-Stager-Stage-Listener" class="headerlink" title="Beacon Stager Stage Listener"></a>Beacon Stager Stage Listener</h1><h2 id="1-Listener：监听器"><a href="#1-Listener：监听器" class="headerlink" title="1. Listener：监听器"></a>1. Listener：监听器</h2><p><strong>作用：</strong><br>Listener 是 Cobalt Strike 设置的一个“通信入口”，用来监听 Beacon 的回连请求。</p>
<ul>
<li>每个 Listener 对应一个通信协议（HTTP&#x2F;HTTPS&#x2F;DNS&#x2F;SMB&#x2F;TCP 等）。</li>
<li>在 TeamServer 上配置后，Beacon 就通过这个 Listener 回连。</li>
</ul>
<hr>
<h2 id="2-Stager：阶段载荷加载器（小型启动器）"><a href="#2-Stager：阶段载荷加载器（小型启动器）" class="headerlink" title="2. Stager：阶段载荷加载器（小型启动器）"></a>2. Stager：阶段载荷加载器（小型启动器）</h2><p><strong>作用：</strong><br>Stager 是一个体积极小的初始 payload，专门用来从 C2 下载真正的 Beacon（也就是 stage），目的是减小落地载荷体积，方便绕过防御。</p>
<p><strong>流程：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[目标主机] ←→ [Stager 载荷] → 请求 Listener → 下载完整 Beacon（stage） → 注入执行</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>体积小（几 KB）；</li>
<li>可以是 shellcode、PowerShell、一段 exe，也可以是 exploit payload；</li>
<li>有点像“下载器”，用来拉取主菜。</li>
</ul>
<hr>
<h2 id="3-Stage：主载荷（Beacon）"><a href="#3-Stage：主载荷（Beacon）" class="headerlink" title="3. Stage：主载荷（Beacon）"></a>3. Stage：主载荷（Beacon）</h2><p><strong>作用：</strong><br>Stage 就是完整功能的 Beacon，包含所有核心逻辑（通信模块、命令处理、内存管理、插件加载等）。</p>
<p>当 Stager 成功运行，会连接 Listener 获取完整的 Beacon（二进制代码）并加载到内存执行。</p>
<p><strong>特点：</strong></p>
<ul>
<li>可以反射注入，不落地；</li>
<li>功能完整，可持久化通信；</li>
<li>体积大（几十到几百 KB）。</li>
</ul>
<hr>
<h2 id="4-Beacon：Cobalt-Strike-的客户端"><a href="#4-Beacon：Cobalt-Strike-的客户端" class="headerlink" title="4. Beacon：Cobalt Strike 的客户端"></a>4. Beacon：Cobalt Strike 的客户端</h2><p><strong>作用：</strong><br>Beacon 是 Cobalt Strike 的 implant，它和 Team Server 通信，等待执行命令。它是 CS 攻击链的核心。</p>
<p><strong>Beacon 的能力：</strong></p>
<ul>
<li>命令执行；</li>
<li>文件上传下载；</li>
<li>横向移动；</li>
<li>注入其他进程；</li>
<li>内存加载模块（BOF）；</li>
<li>通信自适应（切换 sleep、切换通道）；</li>
<li>模拟键盘、屏幕截图、凭证抓取等等。</li>
</ul>
<hr>
<h2 id="举个例子（完整流程）"><a href="#举个例子（完整流程）" class="headerlink" title="举个例子（完整流程）"></a>举个例子（完整流程）</h2><p>假设使用的是 <code>windows/beacon_http/reverse_http</code> 类型的 payload：</p>
<ol>
<li>创建一个 HTTP 类型的 Listener；</li>
<li>生成一个 Stager（例如 PowerShell 脚本）；</li>
<li>用户执行这个 Stager，Stager 向 Listener 发起请求；</li>
<li>Listener 下发完整的 Stage（Beacon）；</li>
<li>Beacon 加载成功，建立持久会话；</li>
<li>后续所有操作通过 Beacon 通信完成。</li>
</ol>
<hr>
<h2 id="简单对比总结"><a href="#简单对比总结" class="headerlink" title="简单对比总结"></a>简单对比总结</h2><table>
<thead>
<tr>
<th>名称</th>
<th>本质</th>
<th>作用</th>
<th>是否落地</th>
</tr>
</thead>
<tbody><tr>
<td>Listener</td>
<td>通信服务端口</td>
<td>Beacon 的接收点</td>
<td>是</td>
</tr>
<tr>
<td>Stager</td>
<td>小型载荷下载器</td>
<td>下载主载荷（stage）</td>
<td>可落地</td>
</tr>
<tr>
<td>Stage</td>
<td>完整的 Beacon</td>
<td>植入目标并执行命令</td>
<td>通常内存</td>
</tr>
<tr>
<td>Beacon</td>
<td>客户端（implant）</td>
<td>和 C2 通信、收发命令</td>
<td>通常内存</td>
</tr>
</tbody></table>
<hr>
<h2 id="实战中常见使用方式"><a href="#实战中常见使用方式" class="headerlink" title="实战中常见使用方式"></a>实战中常见使用方式</h2><ul>
<li><strong>Staged Payload（默认方式）：</strong><br>小载荷负责拉取大载荷，隐蔽性高，但被拦截风险大（多阶段）。</li>
<li><strong>Stageless Payload（不分段）：</strong><br>Beacon 一次性打包在 payload 中，适合写 shellcode loader，体积大但部署简单，绕杀更灵活。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个包含完整 beacon 的 shellcode</span></span><br><span class="line">生成方式：Attacks → Packages → Payload Generator → stageless</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="DPI"><a href="#DPI" class="headerlink" title="DPI"></a>DPI</h1><p><strong>DPI</strong> 是 <strong>Deep Packet Inspection（深度包检测）</strong> 的缩写，是一种网络安全技术，用于深入分析网络通信数据包的内容，而不仅仅是查看数据包的表面信息（如头部信息）。DPI 可以通过检查网络数据包的每一层内容，帮助检测和阻止各种网络威胁、恶意活动和合规性问题。</p>
<p>DPI 在数据包传输过程中逐个检查数据包的每一部分，尤其是数据部分（Payload），以便进行深层次的分析。它与传统的 <strong>包过滤</strong> 技术不同，后者通常只检查数据包的头部信息，如源地址、目的地址、端口号等。</p>
<ol>
<li><strong>数据包捕获</strong>：DPI 设备（例如防火墙、入侵检测系统 IDS、入侵防御系统 IPS）在网络中捕获传输的数据包。</li>
<li><strong>协议分析</strong>：DPI 会解析数据包的每一层协议（例如 IP、TCP、HTTP、DNS 等），并对内容进行深度检查。</li>
<li><strong>模式匹配</strong>：它会查找已知的攻击模式、恶意软件签名或协议的异常行为。</li>
<li><strong>内容检查</strong>：它检查数据包中的内容，包括文件、电子邮件、网页内容、应用数据等，来识别潜在的恶意行为或泄露的信息。</li>
</ol>
<hr>
<h1 id="Cobalt-Strike-的心跳检测"><a href="#Cobalt-Strike-的心跳检测" class="headerlink" title="Cobalt Strike 的心跳检测"></a>Cobalt Strike 的心跳检测</h1><h2 id="Cobalt-Strike-的心跳检测机制"><a href="#Cobalt-Strike-的心跳检测机制" class="headerlink" title="Cobalt Strike 的心跳检测机制"></a>Cobalt Strike 的心跳检测机制</h2><p>Cobalt Strike 的心跳检测机制是用来保持目标系统与 Cobalt Strike 服务器之间稳定连接的技术，防止因网络防御系统（如防火墙、入侵检测系统 IDS）检测到长时间没有活动而切断连接。通过定期发送“心跳包”，Cobalt Strike 可以保持与目标系统的通信，确保不会被中断。</p>
<h2 id="Beacon-的心跳机制是怎么工作的"><a href="#Beacon-的心跳机制是怎么工作的" class="headerlink" title="Beacon 的心跳机制是怎么工作的"></a>Beacon 的心跳机制是怎么工作的</h2><p>Beacon 是被控端，在目标机器里运行后，它会定时主动向 C2（Team Server）“打个招呼”，看看有没有新命令。这个定时打招呼的行为就叫做“心跳”或“回连”。</p>
<h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h3><ul>
<li><strong>通信方式</strong>：Beacon 主动发起 HTTP、HTTPS、DNS、SMB 等请求，向监听器询问“有命令没？”</li>
<li><strong>非长连接</strong>：Beacon 不是 WebSocket 这种实时长连接，而是<strong>轮询式短连接</strong>。</li>
<li><strong>状态无感知</strong>：Beacon 和 Team Server 没有持久连接，断了也不会立刻知道，只能通过心跳间隔判断“它是不是还活着”。</li>
</ul>
<hr>
<h2 id="关键参数：sleep-和-jitter"><a href="#关键参数：sleep-和-jitter" class="headerlink" title="关键参数：sleep 和 jitter"></a>关键参数：sleep 和 jitter</h2><p>Cobalt Strike 中，Beacon 心跳频率是可以<strong>精细配置</strong>的，两个最重要的参数是：</p>
<h3 id="1-sleep"><a href="#1-sleep" class="headerlink" title="1. sleep"></a>1. <code>sleep</code></h3><ul>
<li>表示 Beacon 每次执行完任务后，<strong>等待多长时间再去联系 Team Server</strong>。</li>
<li>默认值是 60 秒，实际操作中推荐设置得更长（比如 150s、300s），降低被发现的概率。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span> 150</span><br></pre></td></tr></table></figure>

<h3 id="2-jitter"><a href="#2-jitter" class="headerlink" title="2. jitter"></a>2. <code>jitter</code></h3><ul>
<li>用来“抖动” sleep 的时间，避免 Beacon 以<strong>固定频率通信被检测</strong>。</li>
<li>jitter 是一个百分比，例如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span> 120 30</span><br></pre></td></tr></table></figure>

<p>表示每次 Beacon 回连的时间为 <strong>120 秒 ± 30%</strong>，即 84~156 秒之间波动。</p>
<hr>
<h2 id="Beacon-的心跳行为具体细节"><a href="#Beacon-的心跳行为具体细节" class="headerlink" title="Beacon 的心跳行为具体细节"></a>Beacon 的心跳行为具体细节</h2><ol>
<li>Beacon 每次 sleep 结束，发起一次请求（HTTP&#x2F;DNS&#x2F;…）；</li>
<li>请求内容包括机器信息、任务请求、状态信息等；</li>
<li>Team Server 返回命令（如果有的话）；</li>
<li>Beacon 执行命令，把结果下一次心跳上传；</li>
<li>重复上述流程。</li>
</ol>
<h3 id="重要特性"><a href="#重要特性" class="headerlink" title="重要特性"></a>重要特性</h3><ul>
<li><strong>非交互性命令</strong>会等下一次心跳才收到；</li>
<li><strong>交互式命令</strong>（比如 shell、powershell）会切换为短 sleep，模拟“实时”交互；</li>
<li>当 Beacon 检测不到 C2 时，会自动重试，但重试间隔也基于 sleep 配置。</li>
</ul>
<hr>
<h2 id="配置-Beacon-的心跳行为"><a href="#配置-Beacon-的心跳行为" class="headerlink" title="配置 Beacon 的心跳行为"></a>配置 Beacon 的心跳行为</h2><p>Cobalt Strike 中可以通过 Beacon Console 配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 Beacon 每 120 秒上线一次，jitter 为 30%</span></span><br><span class="line"><span class="built_in">sleep</span> 120 30</span><br></pre></td></tr></table></figure>

<p>还可以使用 Aggressor Script 来自动配置每个新上线的 Beacon：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on beacon_initial &#123;</span><br><span class="line">  <span class="title function_">binput</span>($1, <span class="string">&quot;sleep 300 20\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="如何检测-Beacon-是否还活着"><a href="#如何检测-Beacon-是否还活着" class="headerlink" title="如何检测 Beacon 是否还活着"></a>如何检测 Beacon 是否还活着</h2><p>Team Server 端会根据 Beacon 的心跳记录来判断状态：</p>
<ul>
<li>如果超出 sleep + jitter 的预期窗口未上线，就会在 Beacon 列表中标红；</li>
<li>可以主动发送命令看看是否响应，间接判断会话是否失效。</li>
</ul>
<hr>
<h2 id="与流量检测的关系"><a href="#与流量检测的关系" class="headerlink" title="与流量检测的关系"></a>与流量检测的关系</h2><p>很多 IDS&#x2F;EDR 就是靠检测 Beacon 的“心跳行为”来识别 C2 通信的：</p>
<ul>
<li>长时间无用户交互却持续访问某 IP；</li>
<li>心跳周期固定；</li>
<li>请求包格式特征明显（如固定 URI、User-Agent）。</li>
</ul>
<h3 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h3><ul>
<li>配置合理的 sleep + jitter；</li>
<li>使用 DNS、HTTPS 通信掩盖真实内容；</li>
<li>配合 Malleable C2 伪装请求头、URL、响应体；</li>
<li>使用分布式 Beacon（SMB 内网跳板、TCP 链式 Beacon）减小出网频率。</li>
</ul>
<h1 id="Beacon-的通信机制"><a href="#Beacon-的通信机制" class="headerlink" title="Beacon 的通信机制"></a>Beacon 的通信机制</h1><h2 id="Beacon-的通信模式：交互式-vs-非交互式"><a href="#Beacon-的通信模式：交互式-vs-非交互式" class="headerlink" title="Beacon 的通信模式：交互式 vs 非交互式"></a>Beacon 的通信模式：交互式 vs 非交互式</h2><h3 id="默认：非交互式（非实时）"><a href="#默认：非交互式（非实时）" class="headerlink" title="默认：非交互式（非实时）"></a>默认：非交互式（非实时）</h3><p>Beacon 默认是在 sleep 间隔内轮询式通信，它执行一个命令，结果等下次回连才传回来。这种模式叫 <strong>non-interactive mode</strong>，优点是隐蔽，缺点是慢。</p>
<h3 id="临时：交互式（实时）"><a href="#临时：交互式（实时）" class="headerlink" title="临时：交互式（实时）"></a>临时：交互式（实时）</h3><p>当操作人员在 Beacon 控制台中使用一些<strong>交互性很强的命令</strong>时，比如：</p>
<ul>
<li><code>shell</code> &#x2F; <code>powershell</code>（临时打开一个 shell）；</li>
<li><code>execute-assembly</code>（手动操作 .NET 程序）；</li>
<li><code>keylogger</code>；</li>
<li><code>browserpivot</code>。</li>
</ul>
<p>Beacon 会临时切换为交互式模式，将 sleep 调整为极短（比如 1s），频繁回连，实现“实时命令响应”。</p>
<p><strong>注意：</strong></p>
<ul>
<li>交互结束后，会自动恢复原本 sleep。</li>
<li>如果遇到防火墙、代理、NDR 监控，频繁访问可能暴露。</li>
</ul>
<p>可以通过命令显式切换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时设置为 5 秒 sleep 进行交互</span></span><br><span class="line"><span class="built_in">sleep</span> 5</span><br><span class="line"><span class="comment"># 恢复为 300s</span></span><br><span class="line"><span class="built_in">sleep</span> 300</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Sleep-Mask-睡眠混淆机制"><a href="#Sleep-Mask-睡眠混淆机制" class="headerlink" title="Sleep Mask 睡眠混淆机制"></a>Sleep Mask 睡眠混淆机制</h2><p>这个是高阶 OPSEC 配置的核心功能之一，尤其针对 <strong>内存扫描</strong> 和 <strong>行为监控</strong> 非常重要。</p>
<h3 id="问题背景："><a href="#问题背景：" class="headerlink" title="问题背景："></a>问题背景：</h3><p>Beacon 在 sleep 过程中虽然没在通信，但它的代码&#x2F;数据依然在内存里，这很容易被杀软扫描器查到。</p>
<p>例如：</p>
<ul>
<li>某段 Beacon shellcode 一直驻留在内存；</li>
<li>某个 DLL 被挂起但签名异常；</li>
<li>某进程占用高权限但无 UI。</li>
</ul>
<h3 id="什么是-Sleep-Mask？"><a href="#什么是-Sleep-Mask？" class="headerlink" title="什么是 Sleep Mask？"></a>什么是 Sleep Mask？</h3><p>Sleep Mask 是一种“<strong>睡眠时清理痕迹</strong>”的技术机制。其核心思想是：</p>
<p>Beacon 进入 sleep 前自动清空&#x2F;加密自己的内存区域，只留下一个极简的恢复 stub。</p>
<h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h3><ol>
<li>Beacon 准备 sleep → 保存状态；</li>
<li>清空或加密自身的内存（包括代码段）；</li>
<li>挂起自己，等待定时器触发；</li>
<li>时间到 → 恢复自身代码 → 继续执行下一步。</li>
</ol>
<h3 id="开启方式："><a href="#开启方式：" class="headerlink" title="开启方式："></a>开启方式：</h3><p>需要配合 BOF 模块，比如使用 <code>sleep_mask</code> BOF，可以让 Beacon 在每次 sleep 时执行自我抹除。</p>
<p>社区里也有不少自定义 Sleep Mask 的 BOF，如：</p>
<ul>
<li>Ekko（ETW Patch + APC 调度）；</li>
<li>Schlock（挂起线程 + shellcode trampoline）；</li>
<li>Sigrun 等。</li>
</ul>
<hr>
<h2 id="如何绕过-Beacon-心跳特征检测"><a href="#如何绕过-Beacon-心跳特征检测" class="headerlink" title="如何绕过 Beacon 心跳特征检测"></a>如何绕过 Beacon 心跳特征检测</h2><p>因为 Beacon 的心跳行为很像“机器人”，所以流量检测系统（EDR&#x2F;NDR&#x2F;IDS）特别爱抓这类流量。</p>
<p>以下是一些常见对抗方式：</p>
<h3 id="1-使用-Malleable-C2-伪装流量"><a href="#1-使用-Malleable-C2-伪装流量" class="headerlink" title="1. 使用 Malleable C2 伪装流量"></a>1. 使用 Malleable C2 伪装流量</h3><ul>
<li>修改 Beacon 的通信 URL（如 <code>/status-check</code> → <code>/cdn/api</code>）；</li>
<li>修改 User-Agent（模拟 Chrome、Edge）；</li>
<li>添加合法 Referer、Cookie；</li>
<li>响应体伪装成 JSON&#x2F;XML 图片资源。</li>
</ul>
<h3 id="2-调整-sleep-jitter"><a href="#2-调整-sleep-jitter" class="headerlink" title="2. 调整 sleep + jitter"></a>2. 调整 sleep + jitter</h3><ul>
<li>把 sleep 调长（如 300s），jitter 拉高（如 40%）；</li>
<li>多个 Beacon 不要统一间隔上线，错开上线时间；</li>
<li>随机插入长时间 sleep，模拟“挂机机器”。</li>
</ul>
<h3 id="3-分离通信链路"><a href="#3-分离通信链路" class="headerlink" title="3. 分离通信链路"></a>3. 分离通信链路</h3><ul>
<li>利用 <strong>SMB Beacon</strong>、<strong>TCP Beacon</strong> 建立内网链路；</li>
<li>让真正出网通信的 Beacon 更少、更稳；</li>
<li>内部横向全部通过内网代理。</li>
</ul>
<h3 id="4-使用-DNS-通信"><a href="#4-使用-DNS-通信" class="headerlink" title="4. 使用 DNS 通信"></a>4. 使用 DNS 通信</h3><ul>
<li>利用 DNS Query 发出命令请求；</li>
<li>响应藏在 TXT 记录或 CNAME 返回中；</li>
<li>流量更像正常 DNS 解析行为，但带宽较小。</li>
</ul>
<h3 id="5-动态加载-Beacon（反射注入）"><a href="#5-动态加载-Beacon（反射注入）" class="headerlink" title="5. 动态加载 Beacon（反射注入）"></a>5. 动态加载 Beacon（反射注入）</h3><ul>
<li>Beacon 不驻留内存，而是使用 loader 每次注入后即销毁；</li>
<li>可结合 sleep mask + reflect loader 实现极端隐蔽。</li>
</ul>
<hr>
<h1 id="Browser-Pivot"><a href="#Browser-Pivot" class="headerlink" title="Browser Pivot"></a>Browser Pivot</h1><p><strong>Browser Pivot（浏览器代理或浏览器跳板）</strong> 是一种高级的后渗透技术，主要用于在已经控制的目标主机上<strong>劫持其浏览器会话</strong>，从而<strong>利用目标用户已登录的浏览器身份访问内部资源、Web应用或系统</strong>，而无需再次进行身份认证。帮助攻击者利用目标主机已有的“合法身份”进行更深层次的横向渗透或数据访问。</p>
<hr>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>你渗透进了一台内网机器，这台机器的用户正在用浏览器访问公司内部的OA系统或开发平台（并已登录），你没有这个系统的账号密码。但通过 Browser Pivot，你可以<strong>借用他的浏览器身份</strong>，以他的权限去访问那些系统，就像你坐在他电脑前操作一样。</p>
<hr>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol>
<li><strong>建立 Beacon 会话</strong>：<ul>
<li>攻击者通过 Cobalt Strike 控制目标主机，并植入了 Beacon（即后门）。</li>
</ul>
</li>
<li><strong>启用 Browser Pivot</strong>：<ul>
<li>在 Beacon 中执行 <code>browserpivot</code> 命令，Cobalt Strike 会注入一个 DLL 到目标机器的浏览器进程中（如 Chrome、Edge 或 IE）。</li>
<li>这个 DLL 会<strong>拦截浏览器发出的 HTTP 请求</strong>，并将其代理转发到 Cobalt Strike。</li>
</ul>
</li>
<li><strong>设置 SOCKS 代理</strong>：<ul>
<li>攻击者可以在自己的机器上设置一个 SOCKS 代理，并通过这个代理访问目标浏览器“正在登录”的 Web 应用。</li>
<li>所有请求都是从目标机器浏览器发出的，服务端会认为是“合法用户”的操作。</li>
</ul>
</li>
<li><strong>访问目标内部系统</strong>：<ul>
<li>攻击者现在可以在自己的浏览器或 Burp Suite 中设置 SOCKS 代理，访问原本无法访问的系统（如内网OA、内网Git、K8s Dashboard等）。</li>
<li>所有请求都继承了目标用户当前的登录状态（如Cookie、Session等），不需要再次输入账号密码。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="与普通代理的区别"><a href="#与普通代理的区别" class="headerlink" title="与普通代理的区别"></a>与普通代理的区别</h2><table>
<thead>
<tr>
<th>特性</th>
<th>普通代理</th>
<th>Browser Pivot</th>
</tr>
</thead>
<tbody><tr>
<td>是否继承登录状态</td>
<td>❌ 不继承</td>
<td>✅ 继承浏览器 Cookie、Session</td>
</tr>
<tr>
<td>是否注入浏览器进程</td>
<td>❌ 不注入</td>
<td>✅ 注入浏览器进程</td>
</tr>
<tr>
<td>是否可绕过认证</td>
<td>❌ 需要账号密码</td>
<td>✅ 可直接用目标已登录会话</td>
</tr>
<tr>
<td>适用目标</td>
<td>网络层面</td>
<td>应用层&#x2F;会话层</td>
</tr>
</tbody></table>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>浏览器必须是已登录状态</strong>：否则 Browser Pivot 没有意义。</li>
<li><strong>有些浏览器启用了防注入机制</strong>（特别是新版 Chrome），可能会失败。</li>
<li><strong>防御方可以通过监测浏览器行为和代理访问异常来识别此类行为</strong>。</li>
</ul>
<hr>
<h1 id="Reflect-Loader"><a href="#Reflect-Loader" class="headerlink" title="Reflect Loader"></a>Reflect Loader</h1><h2 id="Reflective-Loader-是什么"><a href="#Reflective-Loader-是什么" class="headerlink" title="Reflective Loader 是什么"></a>Reflective Loader 是什么</h2><p><strong>Reflective Loader</strong>（反射加载器）是一种内存加载技术，其核心目的是：</p>
<p><strong>在不依赖操作系统的标准加载机制（如 LoadLibrary）和不落地磁盘的情况下，在内存中手动加载并执行 DLL 或 Shellcode。</strong></p>
<p>这种技术常用于：</p>
<ul>
<li><strong>无文件攻击（Fileless）</strong></li>
<li><strong>恶意代码注入</strong></li>
<li><strong>绕过安全软件检测（如 AV &#x2F; EDR）</strong></li>
<li><strong>Cobalt Strike、Metasploit、BOF 等攻击链中的模块加载</strong></li>
</ul>
<hr>
<h2 id="Reflective-Loader-的基本原理"><a href="#Reflective-Loader-的基本原理" class="headerlink" title="Reflective Loader 的基本原理"></a>Reflective Loader 的基本原理</h2><p>传统加载 DLL 的方式（如 <code>LoadLibrary()</code>）：</p>
<ul>
<li>会使用系统 API</li>
<li>会写入磁盘缓存</li>
<li>容易被安全软件检测</li>
</ul>
<p>而 Reflective Loader：</p>
<ul>
<li>自己实现一套完整的 DLL 加载流程</li>
<li>从内存中加载 DLL（如从 Shellcode、远程注入、网络下载等）</li>
<li>不依赖 <code>LoadLibrary</code>，也不生成磁盘文件</li>
<li>可用于执行自定义模块、恶意插件、Beacon 等 payload</li>
</ul>
<p><strong>工作流程如下：</strong></p>
<ol>
<li><strong>从外部接收到一段 DLL 二进制数据</strong>（可能是加密的，也可能是 shellcode 包裹的）</li>
<li><strong>Reflective Loader</strong> 在自身内部完成：<ul>
<li>映射节区</li>
<li>重定位地址</li>
<li>修复导入表（Import Address Table）</li>
<li>处理 TLS 回调</li>
<li>执行 DLL 的入口函数（<code>DllMain</code>）</li>
</ul>
</li>
<li>整个过程<strong>完全发生在内存中</strong></li>
</ol>
<hr>
<h2 id="Reflective-Loader-常用于哪些地方？"><a href="#Reflective-Loader-常用于哪些地方？" class="headerlink" title="Reflective Loader 常用于哪些地方？"></a>Reflective Loader 常用于哪些地方？</h2><table>
<thead>
<tr>
<th>场景</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>红队工具</strong></td>
<td>如 Cobalt Strike 使用 Reflective Loader 加载 Beacon（Payload）到远程进程</td>
</tr>
<tr>
<td><strong>Metasploit</strong></td>
<td>模块 <code>windows/meterpreter/reverse_https</code><br/> 中的 DLL 加载用的是反射技术</td>
</tr>
<tr>
<td><strong>自定义后门 &#x2F; Dropper</strong></td>
<td>利用反射加载器解密并运行内存中的 Payload</td>
</tr>
<tr>
<td><strong>绕过安全检测</strong></td>
<td>避免调用 LoadLibrary 或磁盘读写行为，减少被 AV&#x2F;EDR 检测的机会</td>
</tr>
<tr>
<td><strong>免杀工具链构建</strong></td>
<td>Loader + Reflective DLL + Beacon 组成一条完整免杀攻击链</td>
</tr>
</tbody></table>
<hr>
<h2 id="和普通-DLL-加载的区别"><a href="#和普通-DLL-加载的区别" class="headerlink" title="和普通 DLL 加载的区别"></a>和普通 DLL 加载的区别</h2><table>
<thead>
<tr>
<th>项目</th>
<th>LoadLibrary 加载</th>
<th>Reflective Loader 加载</th>
</tr>
</thead>
<tbody><tr>
<td>是否写入磁盘</td>
<td>是（通常落地）</td>
<td>否（完全在内存）</td>
</tr>
<tr>
<td>是否使用系统 API</td>
<td>是</td>
<td>否（自定义代码）</td>
</tr>
<tr>
<td>是否容易被 AV&#x2F;EDR 拦截</td>
<td>容易</td>
<td>更隐蔽</td>
</tr>
<tr>
<td>加载过程</td>
<td>系统帮你完成</td>
<td>手动完成节区映射、重定位、导入修复</td>
</tr>
<tr>
<td>支持 Shellcode 包装</td>
<td>否</td>
<td>是（常封装成 shellcode）</td>
</tr>
</tbody></table>
<hr>
<h1 id="BOF"><a href="#BOF" class="headerlink" title="BOF"></a>BOF</h1><h2 id="什么是-BOF（Beacon-Object-File）"><a href="#什么是-BOF（Beacon-Object-File）" class="headerlink" title="什么是 BOF（Beacon Object File）"></a>什么是 BOF（Beacon Object File）</h2><h3 id="简单定义"><a href="#简单定义" class="headerlink" title="简单定义"></a>简单定义</h3><p>BOF（Beacon Object File）是 <strong>Cobalt Strike 使用的一种轻量级内存模块</strong>，本质上是用 C 写的 <code>.o</code>（COFF 格式）目标文件，专门设计用于在 Beacon 内部运行的。</p>
<p>可以理解为：<strong>Beacon 的“内存插件”</strong>。</p>
<hr>
<h3 id="为什么需要-BOF"><a href="#为什么需要-BOF" class="headerlink" title="为什么需要 BOF"></a>为什么需要 BOF</h3><p>在早期，Cobalt Strike 想在被控主机上执行一些高级操作（比如获取权限、内存扫描、hook 某模块等），需要：</p>
<ul>
<li>上传一个 EXE&#x2F;DLL；</li>
<li>注入执行；</li>
<li>或者用 PowerShell 调用。</li>
</ul>
<p>问题是这些操作都会：</p>
<ul>
<li>落地磁盘 → 容易被查杀；</li>
<li>调用系统 API 太明显 → EDR 抓得飞起。</li>
</ul>
<p>于是引入 BOF 模型：</p>
<ul>
<li>用 C 编写轻量逻辑；</li>
<li>编译成 <code>.o</code> 文件；</li>
<li>在 Beacon 中由内置解释器运行；</li>
<li>不需要落地、不调用 CreateProcess、甚至可避开常规 API。</li>
</ul>
<hr>
<h3 id="BOF-的工作原理"><a href="#BOF-的工作原理" class="headerlink" title="BOF 的工作原理"></a>BOF 的工作原理</h3><ol>
<li>在攻击机编写 BOF 脚本（C 语言）；</li>
<li>用 MinGW 编译成 <code>.o</code> 文件（COFF 目标文件）；</li>
<li>用 <code>bof</code> 命令加载 <code>.o</code> 文件进 Beacon；</li>
<li>Beacon 在内存中调用内置解释器运行；</li>
<li>操作完成，自动销毁，<strong>内存无残留</strong>。</li>
</ol>
<hr>
<h2 id="Sleep-Mask：与-BOF-结合的隐蔽技术"><a href="#Sleep-Mask：与-BOF-结合的隐蔽技术" class="headerlink" title="Sleep Mask：与 BOF 结合的隐蔽技术"></a>Sleep Mask：与 BOF 结合的隐蔽技术</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>Beacon 在 sleep 过程中虽然暂停执行，但它的代码&#x2F;数据还在内存，可能被：</p>
<ul>
<li>杀软扫描；</li>
<li>EDR 扫描异常 PE 签名；</li>
<li>进程注入分析、代码段遍历等。</li>
</ul>
<p><strong>Sleep Mask</strong> 的目标就是让 Beacon 在“睡着”的时候彻底“藏起来”。</p>
<hr>
<h3 id="Sleep-Mask-原理概述"><a href="#Sleep-Mask-原理概述" class="headerlink" title="Sleep Mask 原理概述"></a>Sleep Mask 原理概述</h3><ol>
<li>Beacon 准备进入 sleep；</li>
<li>执行自我擦除逻辑（自我加密&#x2F;清空）；</li>
<li>设置定时器或挂起；</li>
<li>到时间后 → 自我恢复，继续工作。</li>
</ol>
<h3 id="技术点包括"><a href="#技术点包括" class="headerlink" title="技术点包括"></a>技术点包括</h3><ul>
<li>加密 <code>.text</code> 段（代码段）；</li>
<li>抹除函数符号、导入表；</li>
<li>恢复时重新加载函数地址；</li>
<li>可选使用 APC、Thread Hijack、ETW Patch 技术隐匿恢复动作。</li>
</ul>
<hr>
<h3 id="BOF-如何实现-Sleep-Mask"><a href="#BOF-如何实现-Sleep-Mask" class="headerlink" title="BOF 如何实现 Sleep Mask"></a>BOF 如何实现 Sleep Mask</h3><p>Sleep Mask 逻辑通常是通过一个专用的 BOF 模块完成的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">go</span><span class="params">(<span class="type">char</span> *args, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    mask_beacon();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mask_beacon()</code> 是封装好的加密&#x2F;清除主模块代码逻辑；</li>
<li>BOF 执行后，Beacon 的内存内容在 sleep 期间完全变形；</li>
<li>到时间后自动解密，还原执行流程。</li>
</ul>
<p>有些 BOF 甚至还可以：</p>
<ul>
<li><strong>动态修改 Beacon 模块结构</strong>；</li>
<li><strong>使用 syscalls 替代 WinAPI 进行内存操作</strong>；</li>
<li><strong>完全避免调用敏感函数</strong>（CreateThread、VirtualAlloc 等）。</li>
</ul>
<hr>
<h2 id="Sleep-Mask-BOF-的组合优势"><a href="#Sleep-Mask-BOF-的组合优势" class="headerlink" title="Sleep Mask + BOF 的组合优势"></a>Sleep Mask + BOF 的组合优势</h2><table>
<thead>
<tr>
<th>项目</th>
<th>传统方式</th>
<th>BOF + Sleep Mask</th>
</tr>
</thead>
<tbody><tr>
<td>隐蔽性</td>
<td>一直驻留内存，容易被查</td>
<td>清空内存内容，动态恢复</td>
</tr>
<tr>
<td>落地风险</td>
<td>可能写入磁盘</td>
<td>完全内存中运行</td>
</tr>
<tr>
<td>检测风险</td>
<td>代码签名、模块名暴露</td>
<td>自定义格式、无标准模块</td>
</tr>
<tr>
<td>性能</td>
<td>稳定但占资源</td>
<td>轻量、只执行一次</td>
</tr>
</tbody></table>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><strong>BOF</strong> 是 Beacon 内部运行的轻量模块插件，用 C 写，运行在内存中，无需落地；</li>
<li><strong>Sleep Mask</strong> 是一种在 sleep 期间隐藏自身代码的技术，防止内存扫描被发现；</li>
<li>两者结合，可以极大提升 Beacon 的隐蔽性，绕过杀软、EDR 检测；</li>
<li>是红队中期持久化阶段非常关键的能力。</li>
</ul>
<h1 id="Malleable-C2"><a href="#Malleable-C2" class="headerlink" title="Malleable C2"></a><strong>Malleable C2</strong></h1><h2 id="Malleable-C2：流量伪装引擎"><a href="#Malleable-C2：流量伪装引擎" class="headerlink" title="Malleable C2：流量伪装引擎"></a>Malleable C2：流量伪装引擎</h2><p>Malleable C2 是 Cobalt Strike 中用于<strong>自定义 Beacon 和 Team Server 通信流量外观</strong>的配置机制。它的核心目标是：</p>
<ul>
<li>让 C2 流量“看起来像正常流量”；</li>
<li>绕过 IDS&#x2F;WAF&#x2F;NDR 等基于流量模式的检测；</li>
<li>伪装成合法网站（CDN、API、更新服务等）。</li>
</ul>
<hr>
<h2 id="Malleable-C2-的工作原理"><a href="#Malleable-C2-的工作原理" class="headerlink" title="Malleable C2 的工作原理"></a>Malleable C2 的工作原理</h2><p>默认情况下，Beacon 的回连行为是固定的：</p>
<ul>
<li>请求路径：<code>/submit.php</code></li>
<li>User-Agent：<code>CobaltStrike Beacon</code></li>
<li>数据格式：Base64 编码后的任务包</li>
</ul>
<p>这太容易被规则匹配或流量学习算法检测了。</p>
<p>于是引入 <strong>profile 文件</strong>，可以修改 Beacon 请求的：</p>
<ul>
<li>URI、路径结构；</li>
<li>请求方法（GET&#x2F;POST）；</li>
<li>头部字段（User-Agent、Cookie、Referer 等）；</li>
<li>请求包体（格式、加密、混淆方式）；</li>
<li>响应内容（伪装为图像、JSON、HTML 页面）；</li>
<li>Beacon 的 metadata 加密、编码方式。</li>
</ul>
<hr>
<h2 id="一个简单的-profile-示例"><a href="#一个简单的-profile-示例" class="headerlink" title="一个简单的 profile 示例"></a>一个简单的 profile 示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> useragent <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&quot;</span>;</span><br><span class="line"><span class="built_in">set</span> sleeptime <span class="string">&quot;30000&quot;</span>;  <span class="comment">// 30 秒</span></span><br><span class="line"></span><br><span class="line">http-get &#123;</span><br><span class="line">    <span class="built_in">set</span> uri <span class="string">&quot;/api/status&quot;</span>;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">        header <span class="string">&quot;Accept&quot;</span> <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">        metadata &#123;</span><br><span class="line">            netbios;</span><br><span class="line">            prepend <span class="string">&quot;ID=&quot;</span>;</span><br><span class="line">            base64;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        output &#123;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段配置的含义是：</p>
<ul>
<li>Beacon 回连使用路径 <code>/api/status</code></li>
<li>使用的 User-Agent 是正常浏览器；</li>
<li>将 metadata 结构体用 netbios 编码、base64，再加个 ID&#x3D; 前缀；</li>
<li>Server 端的响应就直接打印出来（可自定义为图片等内容）。</li>
</ul>
<hr>
<h2 id="Malleable-C2-的几个重要块"><a href="#Malleable-C2-的几个重要块" class="headerlink" title="Malleable C2 的几个重要块"></a>Malleable C2 的几个重要块</h2><h3 id="1-http-get-http-post"><a href="#1-http-get-http-post" class="headerlink" title="1. http-get &amp; http-post"></a>1. <code>http-get</code> &amp; <code>http-post</code></h3><p>定义 Beacon 上线请求的行为（GET 请求）和命令执行结果上传行为（POST 请求）。</p>
<p>每个块中可配置：</p>
<ul>
<li><code>uri</code></li>
<li><code>client &#123;&#125;</code>：请求头部 &amp; 编码方式</li>
<li><code>server &#123;&#125;</code>：响应头部 &amp; 内容格式</li>
</ul>
<hr>
<h3 id="2-metadata、id-output-post-ex"><a href="#2-metadata、id-output-post-ex" class="headerlink" title="2. metadata、id, output, post-ex"></a>2. <code>metadata</code>、<code>id</code>, <code>output</code>, <code>post-ex</code></h3><p>这些是 Beacon 与 Team Server 通信时的几种数据类型：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>metadata</code></td>
<td>Beacon 上线时发给 C2 的信息（包括 hostname、user、IP、etc）</td>
</tr>
<tr>
<td><code>id</code></td>
<td>会话 ID，用来识别这个 Beacon</td>
</tr>
<tr>
<td><code>output</code></td>
<td>Beacon 执行命令后的返回数据</td>
</tr>
<tr>
<td><code>post-ex</code></td>
<td>Beacon 执行 post-ex 模块（像 shell、inject）后的数据</td>
</tr>
</tbody></table>
<p>这些字段支持加密、编码、混淆（xor、netbios、base64、prepend、append 等）。</p>
<hr>
<h3 id="3-http-stager-块（仅-staged-payload-使用）"><a href="#3-http-stager-块（仅-staged-payload-使用）" class="headerlink" title="3. http-stager 块（仅 staged payload 使用）"></a>3. <code>http-stager</code> 块（仅 staged payload 使用）</h3><p>定义最初那个 stager 的 HTTP 下载行为（即 Beacon 拉取 stage 时使用的请求样式）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http-stager &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        header <span class="string">&quot;Content-Type&quot;</span> <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">        header <span class="string">&quot;User-Agent&quot;</span> <span class="string">&quot;Mozilla/5.0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="怎么创建并使用-Malleable-C2-配置？"><a href="#怎么创建并使用-Malleable-C2-配置？" class="headerlink" title="怎么创建并使用 Malleable C2 配置？"></a>怎么创建并使用 Malleable C2 配置？</h2><ol>
<li>参考官方样例或 GitHub 上的 Malleable C2 Profile 集合；</li>
<li>使用工具检查合法性：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2lint my.profile</span><br></pre></td></tr></table></figure>

<ol>
<li>启动 teamserver 时加载 profile：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./teamserver &lt;IP&gt; &lt;pass&gt; my.profile</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="实战中常用的伪装思路"><a href="#实战中常用的伪装思路" class="headerlink" title="实战中常用的伪装思路"></a>实战中常用的伪装思路</h2><table>
<thead>
<tr>
<th>模拟对象</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>CDN（Cloudflare）</td>
<td>使用 <code>/cdn-cgi/l/email-protection</code><br/>、图片资源路径</td>
</tr>
<tr>
<td>GitHub API</td>
<td>使用 <code>https://api.github.com/repos/...</code><br/> 结构</td>
</tr>
<tr>
<td>Microsoft Update</td>
<td>模拟 <code>User-Agent: Windows-Update-Agent</code><br/>，路径带 <code>.cab</code></td>
</tr>
<tr>
<td>Google Fonts</td>
<td>路径 <code>/fonts?family=Roboto</code><br/>，响应为 JSON 或 CSS</td>
</tr>
<tr>
<td>JSON API</td>
<td>请求头 Accept 为 <code>application/json</code><br/>，response 返回 JSON 结构包住 output</td>
</tr>
<tr>
<td>图片资源</td>
<td>响应用 <code>Content-Type: image/jpeg</code><br/>，output 藏在图片尾部或 fake jpg header 后</td>
</tr>
</tbody></table>
<hr>
<h1 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h1><p>在 Cobalt Strike 中，<strong>profile 指的就是 Malleable C2 的配置文件</strong>，它是用一种特殊的 DSL（类似 C 的语法）写的文本文件，<strong>用来定义 Beacon 和 Team Server 通信时的“外壳伪装”</strong>。</p>
<p>通俗一点说：</p>
<p>Beacon 的流量要伪装成“正常的网络请求”，profile 就是这张“伪装成什么样”的说明书。</p>
<p>比如：</p>
<ul>
<li>要把流量伪装成访问 GitHub 的样子？</li>
<li>要让流量头部看起来像浏览器请求？</li>
<li>要让传输内容长得像图片？ 这些都可以在 profile 里配置。</li>
</ul>
<hr>
<h2 id="Profile-的作用总结起来就是两点："><a href="#Profile-的作用总结起来就是两点：" class="headerlink" title="Profile 的作用总结起来就是两点："></a>Profile 的作用总结起来就是两点：</h2><ol>
<li><strong>定义 Beacon 与 Team Server 的通信格式（数据结构 + 包样式）</strong>；</li>
<li><strong>控制 Beacon 的行为参数（上线频率、jitter 抖动、user-agent、请求路径等）</strong>。</li>
</ol>
<hr>
<h2 id="Profile-通常包含哪些内容"><a href="#Profile-通常包含哪些内容" class="headerlink" title="Profile 通常包含哪些内容"></a>Profile 通常包含哪些内容</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> sleeptime <span class="string">&quot;60000&quot;</span>;             <span class="comment">// Beacon 心跳时间（毫秒）</span></span><br><span class="line"><span class="built_in">set</span> jitter <span class="string">&quot;25&quot;</span>;                   <span class="comment">// 抖动百分比</span></span><br><span class="line"><span class="built_in">set</span> useragent <span class="string">&quot;Mozilla/5.0&quot;</span>;       <span class="comment">// Beacon 使用的 User-Agent</span></span><br><span class="line"><span class="built_in">set</span> dns_idle <span class="string">&quot;8.8.8.8&quot;</span>;            <span class="comment">// DNS Beacon 模式用的 Idle 值</span></span><br><span class="line"><span class="built_in">set</span> maxdns <span class="string">&quot;255&quot;</span>;                  <span class="comment">// 最大 DNS 包长度</span></span><br><span class="line"></span><br><span class="line">http-get &#123;</span><br><span class="line">    <span class="built_in">set</span> uri <span class="string">&quot;/cdn/api/status&quot;</span>;     <span class="comment">// Beacon GET 请求的路径</span></span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">        header <span class="string">&quot;Accept&quot;</span> <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">        metadata &#123;</span><br><span class="line">            base64;</span><br><span class="line">            prepend <span class="string">&quot;ID=&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        output &#123;</span><br><span class="line">            base64;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一个完整的通信逻辑描述文件。</p>
<hr>
<h2 id="Profile-的生命周期是这样的："><a href="#Profile-的生命周期是这样的：" class="headerlink" title="Profile 的生命周期是这样的："></a>Profile 的生命周期是这样的：</h2><ol>
<li><strong>创建：</strong> 自己手写或用工具生成 profile 文件，后缀不限（通常 <code>.profile</code>）；</li>
<li><strong>加载：</strong> 启动 Cobalt Strike 的 TeamServer 时传入这个文件；</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./teamserver &lt;IP&gt; &lt;password&gt; profile.profile</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>作用：</strong> 所有 Beacon（包括生成的 payload）都会使用该 profile 定义的行为来回连；</li>
<li><strong>修改：</strong> 必须重启 TeamServer 才能生效新的 profile。</li>
</ol>
<hr>
<h2 id="Profile-和-Beacon-是什么关系"><a href="#Profile-和-Beacon-是什么关系" class="headerlink" title="Profile 和 Beacon 是什么关系"></a>Profile 和 Beacon 是什么关系</h2><p>可以这样理解：</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Beacon</td>
<td>负责执行命令 + 回连 Team Server</td>
</tr>
<tr>
<td>Profile</td>
<td>规定 Beacon 的“通信外壳”和行为习惯</td>
</tr>
<tr>
<td>Team Server</td>
<td>接收 Beacon 的流量，并解析 profile 中规定的结构</td>
</tr>
</tbody></table>
<hr>
<h2 id="可以配置哪些行为"><a href="#可以配置哪些行为" class="headerlink" title="可以配置哪些行为"></a>可以配置哪些行为</h2><table>
<thead>
<tr>
<th>行为类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>回连频率</td>
<td><code>set sleeptime</code>、<code>set jitter</code></td>
</tr>
<tr>
<td>请求样式</td>
<td><code>http-get &#123;&#125;</code>、<code>http-post &#123;&#125;</code></td>
</tr>
<tr>
<td>请求内容</td>
<td><code>metadata</code>、<code>id</code>、<code>post-ex</code></td>
</tr>
<tr>
<td>数据编码</td>
<td><code>base64</code>、<code>netbios</code>、<code>mask</code></td>
</tr>
<tr>
<td>流量伪装</td>
<td><code>header</code>、<code>uri</code>、<code>server output</code></td>
</tr>
<tr>
<td>DNS 通信</td>
<td><code>dns-beacon</code>、<code>maxdns</code>、<code>dns_idle</code></td>
</tr>
<tr>
<td>兼容场景</td>
<td><code>os_arch</code>、<code>http-stager</code> 块</td>
</tr>
</tbody></table>
<hr>
<h2 id="实战中怎么用-profile"><a href="#实战中怎么用-profile" class="headerlink" title="实战中怎么用 profile"></a>实战中怎么用 profile</h2><ul>
<li>配合上线场景：伪装成公司常访问的 API（CDN、云盘等）；</li>
<li>绕过 IDS&#x2F;EDR：改掉 Beacon 的默认路径、头部、包结构；</li>
<li>针对性生成 payload：一个 profile 一个 Beacon 风格。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://lyi61pd.github.io">lyi61pd</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://lyi61pd.github.io/2025/04/08/C2/">https://lyi61pd.github.io/2025/04/08/C2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C2/">C2</a><a class="post-meta__tags" href="/tags/%E5%AE%89%E5%85%A8/">安全</a></div><div class="post-share"><div class="social-share" data-image="/blog_imgs/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">数据结构</div></div><div class="info-2"><div class="info-item-1">快速回忆下大学的数据结构课， 这些看完，...</div></div></div></a><a class="pagination-related" href="/2025/04/10/Linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/" title="Linux延迟绑定"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Linux延迟绑定</div></div><div class="info-2"><div class="info-item-1">Windows 下.lib .dll .obj .exe.lib 是静态链接文件 .dll 是动态链接文件 .obj 是编译时生成的中间代码文件，比如一个项目有多个.c 文件，编译时会先全部生成为中间 obj 文件，然后在进行链接生成最终的 exe 文件 .exe 文件是可执行文件 Linux 下.o .so .a.o 类似于 Windows 下的.obj 文件，是编译中间产物 .so 是动态链接文件 .a 是静态链接文件,可通过如下命令将中间文件加进 output.a 或者新生成一个 output.a 12创建.a的命令ar rcx output.a test1.o test2.o  Linux 延迟绑定机制使用的 C 语言例子123456789101112131415161718//-------------------------------------------------------------------// FileName: test1.c// Author: hexuelin// Copyright (c)...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/30/Sliver/" title="Sliver"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-30</div><div class="info-item-2">Sliver</div></div><div class="info-2"><div class="info-item-1">常用命令运行服务 虽然官方文档没提到，但是实际使用下来发现，sliver-server需要root权限，否则没法监听端口，如果使用多用户模式的话，只需要sliver-server使用root权限，sliver-client只需要普通用户权限即可  12345# 正常进入sliver-server的交互式命令行界面sliver-server# 后台跑sliver-server，适用于需要多用户的情况下，但是要先生成用户的配置文件sliver-server daemon  基础命令123456789101112131415161718192021222324252627282930313233# 生成sessiongenerate -b localhost --os linux --skip-symbols --debug -s temp/# 生成beacongenerate beacon -b localhost --skip-symbols --debug -j 1 -S 5 --os linux# 查看生成的beacon和sessionimplants#...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/blog_imgs/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">lyi61pd</div><div class="author-info-description">Im gonna be the best dragon</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lyi61pd"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C2%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">C2基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-C2-%E6%A1%86%E6%9E%B6"><span class="toc-number">1.1.</span> <span class="toc-text">什么是 C2 框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81-C2-%E6%A1%86%E6%9E%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%8B%86%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">主流 C2 框架架构设计拆解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cobalt-Strike"><span class="toc-number">1.2.1.</span> <span class="toc-text">Cobalt Strike</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sliver"><span class="toc-number">1.2.2.</span> <span class="toc-text">Sliver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Metasploit-Framework"><span class="toc-number">1.2.3.</span> <span class="toc-text">Metasploit Framework</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.</span> <span class="toc-text">常见功能模块对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%90%86%E8%A7%A3"><span class="toc-number">1.4.</span> <span class="toc-text">常见问题理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-C2-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E5%A4%9A%E6%A0%B7%E5%8C%96%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">为什么 C2 通信协议多样化重要？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-BOF%EF%BC%88Beacon-Object-File%EF%BC%89%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">什么是 BOF（Beacon Object File）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%9C%E6%97%A0%E6%96%87%E4%BB%B6%E6%94%BB%E5%87%BB%E2%80%9D%EF%BC%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">如何理解“无文件攻击”？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E4%BA%9B%E6%A1%86%E6%9E%B6%E8%83%BD%E6%89%A9%E5%B1%95%E5%90%97%EF%BC%9F"><span class="toc-number">1.4.4.</span> <span class="toc-text">这些框架能扩展吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%98%9F%E7%A0%94%E5%8F%91%E8%AF%A5%E5%A6%82%E4%BD%95%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%BF%99%E4%BA%9B%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">红队研发该如何深入学习这些框架？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cobalt-Strike-1"><span class="toc-number">2.</span> <span class="toc-text">Cobalt Strike</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cobalt-Strike-%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E7%90%86%E8%A7%A3"><span class="toc-number">2.1.</span> <span class="toc-text">Cobalt Strike 架构核心理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Team-Server%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. Team Server（服务端）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Beacon%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%A4%8D%E5%85%A5%E7%AB%AF%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. Beacon（客户端&#x2F;植入端）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Listener%EF%BC%88%E7%9B%91%E5%90%AC%E5%99%A8%EF%BC%89"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. Listener（监听器）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Malleable-C2%EF%BC%9A%E4%BC%AA%E8%A3%85%E5%A4%A7%E5%B8%88"><span class="toc-number">2.2.</span> <span class="toc-text">Malleable C2：伪装大师</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aggressor-Script%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E5%92%8C%E6%89%A9%E5%B1%95%E5%88%A9%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">Aggressor Script：自动化和扩展利器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cobalt-Strike-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97"><span class="toc-number">2.4.</span> <span class="toc-text">Cobalt Strike 的一些经典功能模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%AD%94%E7%96%91"><span class="toc-number">2.5.</span> <span class="toc-text">常见问题答疑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Beacon-%E4%BC%9A%E8%AF%9D%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9C%8B%E8%B5%B7%E6%9D%A5%E2%80%9C%E6%96%AD%E6%96%AD%E7%BB%AD%E7%BB%AD%E2%80%9D%EF%BC%9F"><span class="toc-number">2.5.1.</span> <span class="toc-text">Beacon 会话为什么看起来“断断续续”？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87-Beacon-%E9%9A%90%E8%94%BD%E6%80%A7%EF%BC%9F"><span class="toc-number">2.5.2.</span> <span class="toc-text">如何提升 Beacon 隐蔽性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-BOF-%E6%A8%A1%E5%9D%97%EF%BC%9F"><span class="toc-number">2.5.3.</span> <span class="toc-text">如何使用 BOF 模块？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Aggressor-Script"><span class="toc-number">3.</span> <span class="toc-text">Aggressor Script</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Aggressor-Script-%E8%83%BD%E5%B9%B2%E5%95%A5%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">Aggressor Script 能干啥？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%87%AA%E5%8A%A8%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6%EF%BC%88%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%EF%BC%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. 自动响应事件（事件驱动）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%A9%E5%B1%95%E8%8F%9C%E5%8D%95-UI"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. 扩展菜单 &#x2F; UI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%84%9A%E6%9C%AC"><span class="toc-number">3.1.3.</span> <span class="toc-text">3. 自定义函数 &#x2F; 模块化脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%92%93%E9%B1%BC%E6%96%87%E4%BB%B6%E3%80%81Payload-%E8%BD%BD%E8%8D%B7"><span class="toc-number">3.1.4.</span> <span class="toc-text">4. 自动生成钓鱼文件、Payload 载荷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BD%91%E7%BB%9C%E8%81%94%E5%8A%A8-REST-API-%E8%B0%83%E7%94%A8"><span class="toc-number">3.1.5.</span> <span class="toc-text">5. 网络联动 &#x2F; REST API 调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0-%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%EF%BC%88%E9%80%89%E5%87%A0%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">常用函数&#x2F;命令速查（选几个经典的）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aggressor-Script-%E7%BC%96%E5%86%99-%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.3.</span> <span class="toc-text">Aggressor Script 编写&amp;加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">加载方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Beacon-Stager-Stage-Listener"><span class="toc-number">4.</span> <span class="toc-text">Beacon Stager Stage Listener</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Listener%EF%BC%9A%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">1. Listener：监听器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Stager%EF%BC%9A%E9%98%B6%E6%AE%B5%E8%BD%BD%E8%8D%B7%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E5%B0%8F%E5%9E%8B%E5%90%AF%E5%8A%A8%E5%99%A8%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">2. Stager：阶段载荷加载器（小型启动器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Stage%EF%BC%9A%E4%B8%BB%E8%BD%BD%E8%8D%B7%EF%BC%88Beacon%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">3. Stage：主载荷（Beacon）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Beacon%EF%BC%9ACobalt-Strike-%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">4.4.</span> <span class="toc-text">4. Beacon：Cobalt Strike 的客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%88%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">举个例子（完整流程）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">4.6.</span> <span class="toc-text">简单对比总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%B8%AD%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">4.7.</span> <span class="toc-text">实战中常见使用方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DPI"><span class="toc-number">5.</span> <span class="toc-text">DPI</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cobalt-Strike-%E7%9A%84%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B"><span class="toc-number">6.</span> <span class="toc-text">Cobalt Strike 的心跳检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cobalt-Strike-%E7%9A%84%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">6.1.</span> <span class="toc-text">Cobalt Strike 的心跳检测机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Beacon-%E7%9A%84%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">6.2.</span> <span class="toc-text">Beacon 的心跳机制是怎么工作的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.1.</span> <span class="toc-text">核心机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%8F%82%E6%95%B0%EF%BC%9Asleep-%E5%92%8C-jitter"><span class="toc-number">6.3.</span> <span class="toc-text">关键参数：sleep 和 jitter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-sleep"><span class="toc-number">6.3.1.</span> <span class="toc-text">1. sleep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-jitter"><span class="toc-number">6.3.2.</span> <span class="toc-text">2. jitter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Beacon-%E7%9A%84%E5%BF%83%E8%B7%B3%E8%A1%8C%E4%B8%BA%E5%85%B7%E4%BD%93%E7%BB%86%E8%8A%82"><span class="toc-number">6.4.</span> <span class="toc-text">Beacon 的心跳行为具体细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">6.4.1.</span> <span class="toc-text">重要特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-Beacon-%E7%9A%84%E5%BF%83%E8%B7%B3%E8%A1%8C%E4%B8%BA"><span class="toc-number">6.5.</span> <span class="toc-text">配置 Beacon 的心跳行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B-Beacon-%E6%98%AF%E5%90%A6%E8%BF%98%E6%B4%BB%E7%9D%80"><span class="toc-number">6.6.</span> <span class="toc-text">如何检测 Beacon 是否还活着</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.7.</span> <span class="toc-text">与流量检测的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%AD%96"><span class="toc-number">6.7.1.</span> <span class="toc-text">对策</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Beacon-%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">Beacon 的通信机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Beacon-%E7%9A%84%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BA%A4%E4%BA%92%E5%BC%8F-vs-%E9%9D%9E%E4%BA%A4%E4%BA%92%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">Beacon 的通信模式：交互式 vs 非交互式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%EF%BC%9A%E9%9D%9E%E4%BA%A4%E4%BA%92%E5%BC%8F%EF%BC%88%E9%9D%9E%E5%AE%9E%E6%97%B6%EF%BC%89"><span class="toc-number">7.1.1.</span> <span class="toc-text">默认：非交互式（非实时）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%EF%BC%9A%E4%BA%A4%E4%BA%92%E5%BC%8F%EF%BC%88%E5%AE%9E%E6%97%B6%EF%BC%89"><span class="toc-number">7.1.2.</span> <span class="toc-text">临时：交互式（实时）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sleep-Mask-%E7%9D%A1%E7%9C%A0%E6%B7%B7%E6%B7%86%E6%9C%BA%E5%88%B6"><span class="toc-number">7.2.</span> <span class="toc-text">Sleep Mask 睡眠混淆机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%EF%BC%9A"><span class="toc-number">7.2.1.</span> <span class="toc-text">问题背景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Sleep-Mask%EF%BC%9F"><span class="toc-number">7.2.2.</span> <span class="toc-text">什么是 Sleep Mask？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">7.2.3.</span> <span class="toc-text">工作流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">7.2.4.</span> <span class="toc-text">开启方式：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87-Beacon-%E5%BF%83%E8%B7%B3%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B"><span class="toc-number">7.3.</span> <span class="toc-text">如何绕过 Beacon 心跳特征检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-Malleable-C2-%E4%BC%AA%E8%A3%85%E6%B5%81%E9%87%8F"><span class="toc-number">7.3.1.</span> <span class="toc-text">1. 使用 Malleable C2 伪装流量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B0%83%E6%95%B4-sleep-jitter"><span class="toc-number">7.3.2.</span> <span class="toc-text">2. 调整 sleep + jitter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E7%A6%BB%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF"><span class="toc-number">7.3.3.</span> <span class="toc-text">3. 分离通信链路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-DNS-%E9%80%9A%E4%BF%A1"><span class="toc-number">7.3.4.</span> <span class="toc-text">4. 使用 DNS 通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD-Beacon%EF%BC%88%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%EF%BC%89"><span class="toc-number">7.3.5.</span> <span class="toc-text">5. 动态加载 Beacon（反射注入）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Browser-Pivot"><span class="toc-number">8.</span> <span class="toc-text">Browser Pivot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">8.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E6%99%AE%E9%80%9A%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.3.</span> <span class="toc-text">与普通代理的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.3.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reflect-Loader"><span class="toc-number">9.</span> <span class="toc-text">Reflect Loader</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflective-Loader-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.1.</span> <span class="toc-text">Reflective Loader 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflective-Loader-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">Reflective Loader 的基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflective-Loader-%E5%B8%B8%E7%94%A8%E4%BA%8E%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="toc-number">9.3.</span> <span class="toc-text">Reflective Loader 常用于哪些地方？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C%E6%99%AE%E9%80%9A-DLL-%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.4.</span> <span class="toc-text">和普通 DLL 加载的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BOF"><span class="toc-number">10.</span> <span class="toc-text">BOF</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-BOF%EF%BC%88Beacon-Object-File%EF%BC%89"><span class="toc-number">10.1.</span> <span class="toc-text">什么是 BOF（Beacon Object File）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9A%E4%B9%89"><span class="toc-number">10.1.1.</span> <span class="toc-text">简单定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-BOF"><span class="toc-number">10.1.2.</span> <span class="toc-text">为什么需要 BOF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOF-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">10.1.3.</span> <span class="toc-text">BOF 的工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sleep-Mask%EF%BC%9A%E4%B8%8E-BOF-%E7%BB%93%E5%90%88%E7%9A%84%E9%9A%90%E8%94%BD%E6%8A%80%E6%9C%AF"><span class="toc-number">10.2.</span> <span class="toc-text">Sleep Mask：与 BOF 结合的隐蔽技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><span class="toc-number">10.2.1.</span> <span class="toc-text">问题背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sleep-Mask-%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">10.2.2.</span> <span class="toc-text">Sleep Mask 原理概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E7%82%B9%E5%8C%85%E6%8B%AC"><span class="toc-number">10.2.3.</span> <span class="toc-text">技术点包括</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-Sleep-Mask"><span class="toc-number">10.2.4.</span> <span class="toc-text">BOF 如何实现 Sleep Mask</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sleep-Mask-BOF-%E7%9A%84%E7%BB%84%E5%90%88%E4%BC%98%E5%8A%BF"><span class="toc-number">10.3.</span> <span class="toc-text">Sleep Mask + BOF 的组合优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">10.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Malleable-C2"><span class="toc-number">11.</span> <span class="toc-text">Malleable C2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Malleable-C2%EF%BC%9A%E6%B5%81%E9%87%8F%E4%BC%AA%E8%A3%85%E5%BC%95%E6%93%8E"><span class="toc-number">11.1.</span> <span class="toc-text">Malleable C2：流量伪装引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Malleable-C2-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">11.2.</span> <span class="toc-text">Malleable C2 的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-profile-%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.3.</span> <span class="toc-text">一个简单的 profile 示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Malleable-C2-%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E5%9D%97"><span class="toc-number">11.4.</span> <span class="toc-text">Malleable C2 的几个重要块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-http-get-http-post"><span class="toc-number">11.4.1.</span> <span class="toc-text">1. http-get &amp; http-post</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-metadata%E3%80%81id-output-post-ex"><span class="toc-number">11.4.2.</span> <span class="toc-text">2. metadata、id, output, post-ex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-http-stager-%E5%9D%97%EF%BC%88%E4%BB%85-staged-payload-%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">11.4.3.</span> <span class="toc-text">3. http-stager 块（仅 staged payload 使用）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8-Malleable-C2-%E9%85%8D%E7%BD%AE%EF%BC%9F"><span class="toc-number">11.5.</span> <span class="toc-text">怎么创建并使用 Malleable C2 配置？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BC%AA%E8%A3%85%E6%80%9D%E8%B7%AF"><span class="toc-number">11.6.</span> <span class="toc-text">实战中常用的伪装思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Profile"><span class="toc-number">12.</span> <span class="toc-text">Profile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Profile-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93%E8%B5%B7%E6%9D%A5%E5%B0%B1%E6%98%AF%E4%B8%A4%E7%82%B9%EF%BC%9A"><span class="toc-number">12.1.</span> <span class="toc-text">Profile 的作用总结起来就是两点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Profile-%E9%80%9A%E5%B8%B8%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9"><span class="toc-number">12.2.</span> <span class="toc-text">Profile 通常包含哪些内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Profile-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%9A"><span class="toc-number">12.3.</span> <span class="toc-text">Profile 的生命周期是这样的：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Profile-%E5%92%8C-Beacon-%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-number">12.4.</span> <span class="toc-text">Profile 和 Beacon 是什么关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E9%85%8D%E7%BD%AE%E5%93%AA%E4%BA%9B%E8%A1%8C%E4%B8%BA"><span class="toc-number">12.5.</span> <span class="toc-text">可以配置哪些行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%B8%AD%E6%80%8E%E4%B9%88%E7%94%A8-profile"><span class="toc-number">12.6.</span> <span class="toc-text">实战中怎么用 profile</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/30/Sliver/" title="Sliver">Sliver</a><time datetime="2025-07-30T00:00:00.000Z" title="Created 2025-07-30 00:00:00">2025-07-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/07/%E6%B1%87%E7%BC%96/" title="汇编">汇编</a><time datetime="2025-07-07T00:00:00.000Z" title="Created 2025-07-07 00:00:00">2025-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/30/Git/" title="Git">Git</a><time datetime="2025-06-30T00:00:00.000Z" title="Created 2025-06-30 00:00:00">2025-06-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/Python/" title="Python">Python</a><time datetime="2025-04-22T00:00:00.000Z" title="Created 2025-04-22 00:00:00">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/17/CVE-2021-3156/" title="CVE-2021-3156">CVE-2021-3156</a><time datetime="2025-04-17T00:00:00.000Z" title="Created 2025-04-17 00:00:00">2025-04-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/blog_imgs/banner.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By lyi61pd</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>
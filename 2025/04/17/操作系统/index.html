<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统 | lyi61pd</title><meta name="author" content="lyi61pd"><meta name="copyright" content="lyi61pd"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统的基本概念什么是操作系统操作系统（Operating System，简称 OS）是管理计算机硬件和软件资源的系统程序，是用户与硬件之间的中介。它负责管理 CPU、内存、磁盘、外设等资源，调度任务的执行，并为应用程序提供统一的接口。 常见的操作系统包括 Linux、Windows、macOS、Android、iOS 等。不同的操作系统在用户体验、系统结构和调度策略上各有差异，但其核心机制大体">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://lyi61pd.github.io/2025/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
<meta property="og:site_name" content="lyi61pd">
<meta property="og:description" content="操作系统的基本概念什么是操作系统操作系统（Operating System，简称 OS）是管理计算机硬件和软件资源的系统程序，是用户与硬件之间的中介。它负责管理 CPU、内存、磁盘、外设等资源，调度任务的执行，并为应用程序提供统一的接口。 常见的操作系统包括 Linux、Windows、macOS、Android、iOS 等。不同的操作系统在用户体验、系统结构和调度策略上各有差异，但其核心机制大体">
<meta property="og:locale">
<meta property="og:image" content="https://lyi61pd.github.io/blog_imgs/avatar.png">
<meta property="article:published_time" content="2025-04-17T00:00:00.000Z">
<meta property="article:modified_time" content="2025-07-30T03:40:55.100Z">
<meta property="article:author" content="lyi61pd">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lyi61pd.github.io/blog_imgs/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "操作系统",
  "url": "https://lyi61pd.github.io/2025/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
  "image": "https://lyi61pd.github.io/blog_imgs/avatar.png",
  "datePublished": "2025-04-17T00:00:00.000Z",
  "dateModified": "2025-07-30T03:40:55.100Z",
  "author": [
    {
      "@type": "Person",
      "name": "lyi61pd",
      "url": "https://lyi61pd.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/blog_imgs/avatar.png"><link rel="canonical" href="https://lyi61pd.github.io/2025/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="lyi61pd" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/blog_imgs/banner.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">lyi61pd</span></a><a class="nav-page-title" href="/"><span class="site-name">操作系统</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div></div></nav><div id="post-info"><h1 class="post-title">操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-04-17T00:00:00.000Z" title="Created 2025-04-17 00:00:00">2025-04-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-30T03:40:55.100Z" title="Updated 2025-07-30 03:40:55">2025-07-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><p>操作系统（Operating System，简称 OS）是管理计算机硬件和软件资源的系统程序，是用户与硬件之间的中介。它负责管理 CPU、内存、磁盘、外设等资源，调度任务的执行，并为应用程序提供统一的接口。</p>
<p>常见的操作系统包括 Linux、Windows、macOS、Android、iOS 等。不同的操作系统在用户体验、系统结构和调度策略上各有差异，但其核心机制大体相似。</p>
<hr>
<h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>进程是正在运行的程序实例。操作系统负责创建、调度、终止进程，并提供进程间通信（IPC）机制。多进程系统可以并发运行多个任务，提高资源利用率。</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>操作系统需要管理所有程序的内存空间，避免冲突，并提供抽象的虚拟地址空间，使得每个程序看似拥有完整的内存。分页、分段、交换空间（Swap）等技术常用于内存管理。</p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统是组织和存储数据的结构方式。它定义了文件的命名、权限、目录结构、读写方式等。常见的文件系统包括 FAT32、NTFS、ext4 等。</p>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>所有硬件设备如硬盘、网络卡、显示器等都通过驱动程序与操作系统交互。操作系统负责管理这些设备的访问权限、调度和数据传输。</p>
<h3 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h3><p>操作系统提供命令行界面（CLI）或图形用户界面（GUI），作为用户与系统交互的桥梁。例如 bash、cmd、GNOME 等。</p>
<hr>
<h1 id="进程管理-1"><a href="#进程管理-1" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>进程（Process）是操作系统资源分配的基本单位，是程序在运行时的一个实例。一个程序可以对应多个进程，比如打开多个浏览器窗口，每一个窗口就是一个进程。</p>
<p>操作系统通过进程来实现多任务运行，每个进程都有自己的地址空间、代码、数据和运行状态。</p>
<hr>
<h2 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h2><p>程序是静态的代码文件，是指令和数据的集合，而进程是程序执行时的动态实体。程序可以看作是进程的模板。</p>
<p>简单说，程序是“静止”的，进程是“活着”的。</p>
<hr>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>一个进程在生命周期中通常会经历以下几种状态：</p>
<ul>
<li><strong>就绪（Ready）</strong>：进程已准备好运行，等待 CPU 分配时间片。</li>
<li><strong>运行（Running）</strong>：进程正在使用 CPU 运行指令。</li>
<li><strong>阻塞（Blocked）</strong>：进程等待某个事件（如 I&#x2F;O 完成）而暂停运行。</li>
<li><strong>终止（Terminated）</strong>：进程运行结束，资源被回收。</li>
<li><strong>新建（New）</strong>：刚创建，还未就绪。</li>
<li><strong>挂起（Suspended）</strong>：被系统暂停，可能因资源限制或人工干预。</li>
</ul>
<hr>
<h2 id="上下文切换（Context-Switch）"><a href="#上下文切换（Context-Switch）" class="headerlink" title="上下文切换（Context Switch）"></a>上下文切换（Context Switch）</h2><p>多进程系统中，操作系统需要在不同进程之间切换 CPU 使用权。为了让切换透明且安全，系统会在切换前保存当前进程的状态（寄存器、程序计数器、堆栈指针等），切换后再恢复另一个进程的状态。</p>
<p>这种切换过程称为<strong>上下文切换</strong>。虽然切换频繁带来了并发体验，但频繁上下文切换会引起性能损耗。</p>
<hr>
<h2 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h2><p>线程（Thread）是比进程更小的执行单元。多个线程可以共享同一个进程的资源（如内存），但它们有自己的栈和寄存器。</p>
<ul>
<li>进程是资源分配的单位，线程是 CPU 调度的单位。</li>
<li>线程切换的开销比进程小，因此多线程常用于高性能并发编程。</li>
</ul>
<hr>
<h2 id="多进程与多线程的对比"><a href="#多进程与多线程的对比" class="headerlink" title="多进程与多线程的对比"></a>多进程与多线程的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody><tr>
<td>内存空间</td>
<td>每个进程独立</td>
<td>同一进程的线程共享空间</td>
</tr>
<tr>
<td>创建开销</td>
<td>较大</td>
<td>较小</td>
</tr>
<tr>
<td>通信方式</td>
<td>使用进程间通信（IPC）</td>
<td>直接共享内存，需同步控制</td>
</tr>
<tr>
<td>稳定性</td>
<td>一个进程崩溃不会影响其他</td>
<td>一个线程崩溃可能影响整个进程</td>
</tr>
<tr>
<td>适用场景</td>
<td>安全隔离、重任务分工</td>
<td>轻量级并发、高 IO 效率</td>
</tr>
</tbody></table>
<hr>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>操作系统在多个进程之间分配 CPU 的方式称为调度。不同的调度算法适用于不同场景：</p>
<ul>
<li><strong>先来先服务（FCFS）</strong>：按进程到达顺序排队处理，简单但不公平。</li>
<li><strong>短作业优先（SJF）</strong>：优先处理运行时间短的任务，平均等待时间短，但可能饿死长任务。</li>
<li><strong>时间片轮转（RR）</strong>：给每个进程分配固定时间片，公平性好，适合分时系统。</li>
<li><strong>优先级调度</strong>：按优先级执行高的进程，易导致低优先级进程长时间等待。</li>
<li><strong>多级反馈队列（MLFQ）</strong>：动态调整进程优先级，综合考虑响应时间和公平性，复杂但实用。</li>
<li><strong>完全公平调度（CFS）</strong>：CFS 通过维护一个 <strong>红黑树</strong> 来管理所有可执行进程。每个进程会根据其 <strong>虚拟运行时间</strong>（也称为“权重”或“时间片”）被放置在红黑树中，进程的虚拟运行时间越小，越先被调度执行。Linux默认采用该算法。CFS 设计的目标是确保每个进程（或线程）都能公平地共享 CPU 时间，从而实现较为平衡的性能表现，特别是对于多核和多线程的环境</li>
</ul>
<hr>
<h2 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h2><p>当多个进程需要协作时，就必须进行通信。常见的通信方式包括：</p>
<ul>
<li><strong>管道（Pipe）</strong>：一种半双工通信机制，只能在父子进程之间使用。</li>
<li><strong>命名管道（FIFO）</strong>：增强版的管道，支持不相关进程间通信。</li>
<li><strong>消息队列</strong>：进程以消息为单位进行通信，系统管理消息缓冲区。</li>
<li><strong>共享内存</strong>：最高效的通信方式，多个进程访问同一块物理内存，但需要加锁同步。</li>
<li><strong>信号量</strong>：主要用于同步机制，避免竞争条件。</li>
<li><strong>套接字（Socket）</strong>：支持不同主机之间的进程通信。</li>
</ul>
<hr>
<h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><p>当多个线程或进程共享资源时，必须保证数据一致性，避免“竞态条件”（Race Condition）。这需要使用同步和互斥机制：</p>
<ul>
<li><strong>互斥锁（Mutex）</strong>：一段代码在同一时刻只能被一个线程访问。</li>
<li><strong>信号量（Semaphore）</strong>：一种计数锁，可以控制访问某资源的线程数。</li>
<li><strong>自旋锁（Spinlock）</strong>：不断尝试获取锁，适合锁持有时间短的场景。</li>
<li><strong>条件变量</strong>：配合锁使用，实现复杂的等待-唤醒机制。</li>
</ul>
<hr>
<h1 id="进程间通信（IPC）-1"><a href="#进程间通信（IPC）-1" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h1><p>在多进程系统中，不同的进程运行在独立的内存空间中，默认情况下彼此之间无法直接访问对方的数据。然而，实际应用中很多任务都需要多个进程协作完成，这就必须依赖进程间通信机制（IPC）来交换数据、传递信号或同步行为。</p>
<p>操作系统提供了多种 IPC 方法，不同的方法适用于不同的场景，权衡了效率、复杂度和安全性。</p>
<hr>
<h2 id="IPC-的典型用途"><a href="#IPC-的典型用途" class="headerlink" title="IPC 的典型用途"></a>IPC 的典型用途</h2><ul>
<li>数据传输：在进程之间传递数据，例如图像处理中的主进程和工作进程。</li>
<li>事件通知：某进程完成任务后通知另一个进程，如 GUI 与后台服务的交互。</li>
<li>资源共享：多个进程共同使用某个资源时，通过同步机制避免冲突。</li>
<li>进程控制：父进程控制子进程的行为，如终止、暂停、唤醒等。</li>
</ul>
<hr>
<h2 id="常见的进程间通信方式"><a href="#常见的进程间通信方式" class="headerlink" title="常见的进程间通信方式"></a>常见的进程间通信方式</h2><h3 id="管道（Pipe）"><a href="#管道（Pipe）" class="headerlink" title="管道（Pipe）"></a>管道（Pipe）</h3><p>管道是一种最基础的 IPC 方式，只能在<strong>有亲缘关系的进程之间使用</strong>，如父子进程。</p>
<ul>
<li>单向传输，数据只能从写端流向读端。</li>
<li>典型用法：<code>ls | grep &quot;txt&quot;</code>，Shell 会创建两个进程，用管道连接它们的输出和输入。</li>
</ul>
<p><strong>系统调用：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<p><code>fd[0]</code> 是读端，<code>fd[1]</code> 是写端。</p>
<h3 id="命名管道（FIFO）"><a href="#命名管道（FIFO）" class="headerlink" title="命名管道（FIFO）"></a>命名管道（FIFO）</h3><p>命名管道是管道的增强版本，<strong>允许无血缘关系的进程通信</strong>，通过文件系统中的特殊文件来标识。</p>
<ul>
<li>数据读写像文件操作一样进行。</li>
<li>可以跨进程、甚至跨 Shell 通信。</li>
<li>使用 <code>mkfifo()</code> 或 <code>mknod()</code> 创建。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> /tmp/myfifo</span><br></pre></td></tr></table></figure>

<h3 id="消息队列（Message-Queue）"><a href="#消息队列（Message-Queue）" class="headerlink" title="消息队列（Message Queue）"></a>消息队列（Message Queue）</h3><p>消息队列允许进程以<strong>消息为单位异步通信</strong>。内核负责缓存消息，进程读取时按消息顺序或优先级读取。</p>
<ul>
<li>支持多生产者、多消费者模型。</li>
<li>消息结构化，通信可靠。</li>
<li>不共享内存，较安全。</li>
</ul>
<p><strong>系统调用：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgget(), msgsnd(), msgrcv(), msgctl()</span><br></pre></td></tr></table></figure>

<h3 id="共享内存（Shared-Memory）"><a href="#共享内存（Shared-Memory）" class="headerlink" title="共享内存（Shared Memory）"></a>共享内存（Shared Memory）</h3><p>共享内存将一块物理内存映射到多个进程的地址空间，是<strong>效率最高</strong>的一种通信方式。</p>
<ul>
<li>多个进程可以同时读写共享区域，适合高频数据交换。</li>
<li>通常需要配合信号量或互斥锁来同步访问，避免数据竞争。</li>
<li>适合大数据量的传输场景，如图像处理、视频编码等。</li>
</ul>
<p><strong>系统调用：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmget(), shmat(), shmdt(), shmctl()</span><br></pre></td></tr></table></figure>

<h3 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h3><p>信号量并不直接传输数据，而是用于实现<strong>进程间的同步与互斥控制</strong>。</p>
<ul>
<li>类似交通红绿灯，控制进程对共享资源的访问。</li>
<li>信号量可与共享内存搭配使用，实现高效且安全的通信。</li>
</ul>
<p><strong>系统调用：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semget(), semop(), semctl()</span><br></pre></td></tr></table></figure>

<h3 id="信号（Signal）"><a href="#信号（Signal）" class="headerlink" title="信号（Signal）"></a>信号（Signal）</h3><p>信号是一种轻量级的通知机制，操作系统通过信号向进程传递事件通知。</p>
<ul>
<li>类似中断，用于处理如中止、超时、非法访问等事件。</li>
<li>常见信号有 <code>SIGINT</code>（Ctrl+C）、<code>SIGKILL</code>、<code>SIGTERM</code> 等。</li>
<li>可自定义信号处理函数，使用 <code>signal()</code> 或 <code>sigaction()</code> 注册。</li>
</ul>
<h3 id="套接字（Socket）"><a href="#套接字（Socket）" class="headerlink" title="套接字（Socket）"></a>套接字（Socket）</h3><p>套接字支持<strong>不同主机或本机任意进程之间的通信</strong>，是构建网络通信的基础。</p>
<ul>
<li>分为**本地套接字（Unix Domain Socket）<strong><strong>和</strong></strong>网络套接字（TCP&#x2F;UDP）**。</li>
<li>本地套接字用于同一台机器内的进程通信，性能高于 TCP 套接字。</li>
<li>网络套接字支持跨主机通信，是分布式系统通信的核心方式。</li>
</ul>
<p><strong>系统调用：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket(), bind(), listen(), accept(), connect(), send(), recv()</span><br></pre></td></tr></table></figure>

<p>socket有多种不同类型，比如常见的<code>ip:port</code>是网络套接字</p>
<table>
<thead>
<tr>
<th>socket 类型</th>
<th>地址格式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>AF_INET</code></td>
<td><code>IP:PORT</code></td>
<td>IPv4 网络通信</td>
</tr>
<tr>
<td><code>AF_INET6</code></td>
<td><code>[IPv6]:PORT</code></td>
<td>IPv6 网络通信</td>
</tr>
<tr>
<td><code>AF_UNIX</code> &#x2F; <code>AF_LOCAL</code></td>
<td>文件路径（如 <code>/tmp/mysock</code>）</td>
<td>本地进程通信（IPC）</td>
</tr>
<tr>
<td><code>AF_PACKET</code></td>
<td>网络接口 + 协议</td>
<td>底层网络抓包（如 Wireshark）</td>
</tr>
<tr>
<td><code>AF_BLUETOOTH</code></td>
<td>MAC 地址 + 通道</td>
<td>蓝牙通信</td>
</tr>
<tr>
<td><code>AF_NETLINK</code></td>
<td>内核通信通道</td>
<td>Linux 内核与用户空间通信</td>
</tr>
</tbody></table>
<hr>
<h2 id="实际开发中如何选择-IPC-方式"><a href="#实际开发中如何选择-IPC-方式" class="headerlink" title="实际开发中如何选择 IPC 方式"></a>实际开发中如何选择 IPC 方式</h2><ul>
<li>对于高频大数据传输：优先使用共享内存 + 同步机制</li>
<li>对于结构化、可靠消息传递：使用消息队列或本地套接字</li>
<li>对于跨主机通信：使用网络套接字（如 TCP）</li>
<li>对于简单通知或事件触发：使用信号或信号量</li>
<li>父子进程间传输：使用管道或共享内存</li>
<li>多线程通信：直接共享内存，配合互斥锁或条件变量</li>
</ul>
<hr>
<h1 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存管理的作用"><a href="#内存管理的作用" class="headerlink" title="内存管理的作用"></a>内存管理的作用</h2><p>内存管理的目标是高效、安全、合理地分配系统内存资源。现代操作系统通过内存管理机制，让每个进程都以为自己拥有完整的独立内存空间，实际上却在后台进行着复杂的资源调度和地址映射。</p>
<p>内存管理不仅负责分配和回收内存，还必须处理内存保护、共享、虚拟化等需求。</p>
<hr>
<h2 id="地址空间与地址类型"><a href="#地址空间与地址类型" class="headerlink" title="地址空间与地址类型"></a>地址空间与地址类型</h2><h3 id="逻辑地址（虚拟地址）"><a href="#逻辑地址（虚拟地址）" class="headerlink" title="逻辑地址（虚拟地址）"></a>逻辑地址（虚拟地址）</h3><p>逻辑地址是由程序生成的地址，也叫虚拟地址。在程序中访问内存时，使用的就是逻辑地址。</p>
<h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>物理地址是真正被映射到内存芯片上的地址，由硬件识别。操作系统通过内存管理单元（MMU）将逻辑地址转换成物理地址。</p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><ul>
<li><strong>逻辑地址空间</strong>：进程能看到的内存范围。</li>
<li><strong>物理地址空间</strong>：实际硬件可用的内存范围。</li>
</ul>
<p>每个进程有独立的逻辑地址空间，操作系统通过地址转换机制将其映射到共享的物理内存上。</p>
<hr>
<h2 id="分段（Segmentation）"><a href="#分段（Segmentation）" class="headerlink" title="分段（Segmentation）"></a>分段（Segmentation）</h2><p>分段是一种将逻辑地址空间划分为多个“逻辑单元”的方法，比如代码段、数据段、堆、栈等。</p>
<ul>
<li>每段具有独立的基址和长度。</li>
<li>程序更容易实现模块化管理。</li>
<li>缺点是段长不固定，容易产生<strong>外部碎片</strong>。</li>
</ul>
<p>分段常用于早期操作系统或嵌入式系统，在现代系统中通常结合分页一起使用。</p>
<p><img src="/blog_imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1744796674197-5bc113a6-e168-4e5f-8cfa-24e10af5889c.png"></p>
<hr>
<h2 id="分页（Paging）"><a href="#分页（Paging）" class="headerlink" title="分页（Paging）"></a>分页（Paging）</h2><p>分页是将<strong>物理内存和逻辑内存都划分成等大小的固定块</strong>，分别叫做：</p>
<ul>
<li>页（Page）：逻辑内存单位</li>
<li>帧（Frame）：物理内存单位</li>
</ul>
<p>操作系统维护一个<strong>页表（Page Table）</strong>，用于将每个页映射到对应的帧，解决了分段带来的外部碎片问题。</p>
<ul>
<li>每个进程都有自己的页表</li>
<li>地址转换过程由 MMU 自动完成</li>
</ul>
<h3 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h3><p>逻辑地址 &#x3D; 页号 + 页内偏移<br>查页表得到帧号，组合成物理地址。</p>
<hr>
<h2 id="虚拟内存（Virtual-Memory）"><a href="#虚拟内存（Virtual-Memory）" class="headerlink" title="虚拟内存（Virtual Memory）"></a>虚拟内存（Virtual Memory）</h2><p>虚拟内存是操作系统通过分页机制提供的一种内存扩展技术。即使物理内存不足，也可以通过将部分内存页暂存到磁盘（称为<strong>交换空间</strong>或 Swap）来继续执行程序。</p>
<ul>
<li>提供了比实际物理内存更大的地址空间</li>
<li>支持按需调页，程序启动时不需要全部加载到内存</li>
<li>支持内存共享和内存保护机制</li>
</ul>
<hr>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>当内存不足，必须将一部分内存页换出磁盘，空出空间加载新页，这称为<strong>页面置换</strong>。操作系统使用页面置换算法来决定“淘汰哪一页”。</p>
<p>常见算法包括：</p>
<h3 id="FIFO（先进先出）"><a href="#FIFO（先进先出）" class="headerlink" title="FIFO（先进先出）"></a>FIFO（先进先出）</h3><p>最早进入内存的页最先被换出，简单但效率不佳，容易出现 Belady 异常（缓存更大反而更差）。</p>
<h3 id="LRU（最近最少使用）"><a href="#LRU（最近最少使用）" class="headerlink" title="LRU（最近最少使用）"></a>LRU（最近最少使用）</h3><p>淘汰最近最少使用的页，基于访问历史，命中率高，但实现复杂，通常需要硬件支持或近似算法。</p>
<h3 id="Clock（时钟算法）"><a href="#Clock（时钟算法）" class="headerlink" title="Clock（时钟算法）"></a>Clock（时钟算法）</h3><p>一种 LRU 的近似实现，使用一个“指针”遍历页表，查看是否被访问过，没访问的就换出。</p>
<hr>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>操作系统在分配内存块时，也使用了不同的策略：</p>
<ul>
<li><strong>首次适配（First Fit）</strong>：从头开始找第一个够用的空闲块</li>
<li><strong>最佳适配（Best Fit）</strong>：找最接近所需大小的空闲块，减少碎片</li>
<li><strong>最差适配（Worst Fit）</strong>：找最大的空闲块，预留更多剩余空间</li>
</ul>
<p>这些策略都面临一个问题：<strong>内存碎片</strong>，包括：</p>
<ul>
<li><strong>外部碎片</strong>：空闲块分布零散，总空间够但连续不够</li>
<li><strong>内部碎片</strong>：分配的块比实际需求大，造成浪费</li>
</ul>
<p>分页能很好地解决这两个问题，但会带来页表维护开销。</p>
<hr>
<h2 id="多级页表与快表（TLB）"><a href="#多级页表与快表（TLB）" class="headerlink" title="多级页表与快表（TLB）"></a>多级页表与快表（TLB）</h2><p>在分页系统中，页表过大时会引起访问效率下降。为了解决这个问题，操作系统引入了：</p>
<ul>
<li><strong>多级页表</strong>：将页表本身分页，分层管理，节省内存空间</li>
<li><strong>TLB（Translation Lookaside Buffer）</strong>：一种缓存页表项的高速缓冲区，提升地址转换速度</li>
</ul>
<p>如果页表命中 TLB，地址转换非常快；如果未命中，就需要多次内存访问。</p>
<hr>
<h2 id="内存保护与共享"><a href="#内存保护与共享" class="headerlink" title="内存保护与共享"></a>内存保护与共享</h2><p>现代操作系统通过 MMU 提供内存保护机制：</p>
<ul>
<li>每个进程只能访问自己的地址空间</li>
<li>通过设置页表项中的访问权限，实现读写保护</li>
<li>共享内存（如动态链接库）可以被多个进程映射到相同的物理帧上，提升内存利用率</li>
</ul>
<hr>
<h2 id="典型案例：Linux-内存结构"><a href="#典型案例：Linux-内存结构" class="headerlink" title="典型案例：Linux 内存结构"></a>典型案例：Linux 内存结构</h2><p>在 Linux 中，每个进程的虚拟地址空间大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">高地址</span><br><span class="line">---------------------</span><br><span class="line">内核空间</span><br><span class="line">---------------------</span><br><span class="line">用户堆栈（Stack）</span><br><span class="line">共享库（.so）</span><br><span class="line">堆（Heap）</span><br><span class="line">未初始化数据段（.bss）</span><br><span class="line">初始化数据段（.data）</span><br><span class="line">代码段（.text）</span><br><span class="line">---------------------</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure>

<p>堆向上增长，栈向下增长，这样可以更好地利用地址空间。</p>
<hr>
<h1 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件系统的作用"><a href="#文件系统的作用" class="headerlink" title="文件系统的作用"></a>文件系统的作用</h2><p>文件系统是操作系统中负责管理和存储数据的子系统，其核心目标是为用户提供一种<strong>抽象、统一、安全、高效</strong>的数据访问方式。</p>
<p>通过文件系统，用户可以方便地创建、读取、修改、删除文件和目录，而无需关心底层磁盘的组织方式。</p>
<hr>
<h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p>从操作系统角度看，文件是<strong>逻辑上的字节序列</strong>，可以是文本、图片、程序、数据库文件等。文件通常包括以下信息：</p>
<ul>
<li><strong>文件数据</strong>：实际内容</li>
<li><strong>元数据（Metadata）</strong>：描述文件的属性，如文件名、大小、创建时间、权限等</li>
</ul>
<hr>
<h2 id="文件目录组织"><a href="#文件目录组织" class="headerlink" title="文件目录组织"></a>文件目录组织</h2><p>为了便于管理大量文件，操作系统使用目录结构进行层级分类。常见目录结构包括：</p>
<h3 id="单层目录结构"><a href="#单层目录结构" class="headerlink" title="单层目录结构"></a>单层目录结构</h3><p>所有文件存储在一个目录下，简单但混乱，不适合多用户系统。</p>
<h3 id="二级目录结构"><a href="#二级目录结构" class="headerlink" title="二级目录结构"></a>二级目录结构</h3><p>每个用户一个独立目录，解决了命名冲突，但目录层级仍然不够丰富。</p>
<h3 id="树形目录结构（现代系统通用）"><a href="#树形目录结构（现代系统通用）" class="headerlink" title="树形目录结构（现代系统通用）"></a>树形目录结构（现代系统通用）</h3><p>支持多层嵌套子目录，灵活且可扩展。路径分为：</p>
<ul>
<li><strong>绝对路径</strong>：从根目录 <code>/</code> 开始，如 <code>/home/user***/docs</code></li>
<li><strong>相对路径</strong>：基于当前目录，如 <code>../images</code></li>
</ul>
<hr>
<h2 id="inode（索引节点）"><a href="#inode（索引节点）" class="headerlink" title="inode（索引节点）"></a>inode（索引节点）</h2><p>Linux 等类 Unix 系统中，每个文件都有一个唯一的<strong>索引节点（inode）</strong>，用于记录文件的元数据和磁盘位置。</p>
<p>inode 包含以下信息：</p>
<ul>
<li>文件类型（普通文件、目录、符号链接等）</li>
<li>文件权限（rwx）</li>
<li>所有者 UID、组 GID</li>
<li>创建、访问、修改时间</li>
<li>文件大小</li>
<li>指向数据块的指针</li>
</ul>
<p>文件名和 inode 是分离的。多个文件名可以指向同一个 inode（硬链接）。</p>
<hr>
<h2 id="文件的访问权限"><a href="#文件的访问权限" class="headerlink" title="文件的访问权限"></a>文件的访问权限</h2><p>Unix 系统使用<strong>三类用户 + 三种权限</strong>的模型：</p>
<ul>
<li>用户类型：<ul>
<li>所有者（User）</li>
<li>所在组（Group）</li>
<li>其他用户（Others）</li>
</ul>
</li>
<li>权限类型：<ul>
<li>读（r）：查看文件内容或目录列表</li>
<li>写（w）：修改文件内容或目录结构</li>
<li>执行（x）：运行文件或进入目录</li>
</ul>
</li>
</ul>
<p>例如权限串 <code>-rw-r--r--</code> 表示一个普通文件，拥有者可读写，组和其他用户只读。</p>
<hr>
<h2 id="磁盘空间的分配方式"><a href="#磁盘空间的分配方式" class="headerlink" title="磁盘空间的分配方式"></a>磁盘空间的分配方式</h2><p>文件的数据被存储在磁盘块（block）中，磁盘块的分配方式会影响读写性能和碎片率：</p>
<h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p>文件占用连续的磁盘块，读写性能高，但不利于文件扩展，容易产生外部碎片。</p>
<h3 id="链式分配"><a href="#链式分配" class="headerlink" title="链式分配"></a>链式分配</h3><p>每个磁盘块中记录下一个块的地址，文件可任意扩展，但随机访问性能差。</p>
<h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><p>每个文件有一个索引块，记录所有数据块的地址，灵活且易于管理，是现代文件系统的主流方式。</p>
<hr>
<h2 id="常见文件系统类型"><a href="#常见文件系统类型" class="headerlink" title="常见文件系统类型"></a>常见文件系统类型</h2><h3 id="FAT（File-Allocation-Table）"><a href="#FAT（File-Allocation-Table）" class="headerlink" title="FAT（File Allocation Table）"></a>FAT（File Allocation Table）</h3><ul>
<li>早期 Windows 使用，简单但易碎片化</li>
<li>无权限管理机制，适合 U 盘、存储卡等移动设备</li>
</ul>
<h3 id="NTFS（Windows-默认）"><a href="#NTFS（Windows-默认）" class="headerlink" title="NTFS（Windows 默认）"></a>NTFS（Windows 默认）</h3><ul>
<li>支持权限控制、日志、压缩、加密等特性</li>
<li>稳定性和扩展性好，适用于大型存储系统</li>
</ul>
<h3 id="ext-系列（Linux）"><a href="#ext-系列（Linux）" class="headerlink" title="ext 系列（Linux）"></a>ext 系列（Linux）</h3><ul>
<li><code>ext3</code>：支持日志机制</li>
<li><code>ext4</code>：支持大文件、文件系统检查更快，广泛应用于 Linux 发行版</li>
</ul>
<h3 id="XFS、ZFS、Btrfs-等"><a href="#XFS、ZFS、Btrfs-等" class="headerlink" title="XFS、ZFS、Btrfs 等"></a>XFS、ZFS、Btrfs 等</h3><ul>
<li>更现代的文件系统，支持快照、复制、自动修复等高级特性，适用于云计算和企业环境</li>
</ul>
<hr>
<h2 id="缓存与写入机制"><a href="#缓存与写入机制" class="headerlink" title="缓存与写入机制"></a>缓存与写入机制</h2><p>操作系统并不会每次写入都直接同步到磁盘，而是使用<strong>缓存机制</strong>提升性能：</p>
<ul>
<li><strong>页缓存（Page Cache）</strong>：内存中保存文件内容</li>
<li><strong>写回机制（Write-back）</strong>：延迟写入，提高效率</li>
<li><strong>写通机制（Write-through）</strong>：写操作同步写入磁盘，更安全但性能差</li>
</ul>
<p>可以使用 <code>fsync()</code> 或 <code>sync</code> 命令强制刷新缓存。</p>
<hr>
<h2 id="符号链接与硬链接"><a href="#符号链接与硬链接" class="headerlink" title="符号链接与硬链接"></a>符号链接与硬链接</h2><h3 id="硬链接（Hard-Link）"><a href="#硬链接（Hard-Link）" class="headerlink" title="硬链接（Hard Link）"></a>硬链接（Hard Link）</h3><ul>
<li>多个文件名指向同一个 inode</li>
<li>删除任意一个不会影响其他链接</li>
<li>不能跨文件系统或对目录使用</li>
</ul>
<h3 id="符号链接（Symbolic-Link）"><a href="#符号链接（Symbolic-Link）" class="headerlink" title="符号链接（Symbolic Link）"></a>符号链接（Symbolic Link）</h3><ul>
<li>类似快捷方式，指向目标文件路径</li>
<li>本质是一个独立文件</li>
<li>可以跨文件系统使用</li>
</ul>
<hr>
<h2 id="文件系统的挂载与卸载"><a href="#文件系统的挂载与卸载" class="headerlink" title="文件系统的挂载与卸载"></a>文件系统的挂载与卸载</h2><p>在 Unix&#x2F;Linux 中，所有设备上的文件系统都被“挂载”到主目录树上。</p>
<ul>
<li>使用 <code>mount</code> 命令将设备挂载到某个目录</li>
<li>使用 <code>umount</code> 卸载</li>
<li><code>/etc/fstab</code> 可配置开机自动挂载项</li>
</ul>
<p>挂载是将不同存储介质的内容统一整合到单一的目录结构中。</p>
<hr>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p><strong>文件描述符（File Descriptor，FD）</strong> 是一个相对抽象的概念，但它在操作系统（尤其是 Linux&#x2F;Unix 系统）中起着至关重要的作用。简而言之，文件描述符是一个整数，用于标识一个打开的文件或 I&#x2F;O 资源（如套接字、管道等）。</p>
<h3 id="文件描述符的基本概念"><a href="#文件描述符的基本概念" class="headerlink" title="文件描述符的基本概念"></a>文件描述符的基本概念</h3><p>在 Linux&#x2F;Unix 系统中，当一个进程打开一个文件或设备时，操作系统会分配一个文件描述符来引用该文件或设备。进程通过文件描述符与文件或设备进行交互，而不是直接操作文件名或设备。</p>
<p>可以将文件描述符看作是一个“<strong>索引</strong>”，它指向操作系统内核中的一个数据结构，该数据结构描述了打开文件的相关信息，如文件的位置、文件的读写权限、文件的类型等。</p>
<h3 id="文件描述符的范围"><a href="#文件描述符的范围" class="headerlink" title="文件描述符的范围"></a>文件描述符的范围</h3><ul>
<li><strong>标准输入（stdin）</strong>：文件描述符 0</li>
<li><strong>标准输出（stdout）</strong>：文件描述符 1</li>
<li><strong>标准错误（stderr）</strong>：文件描述符 2</li>
</ul>
<p>这些是系统启动时就自动打开的文件描述符，通常用来处理命令行输入输出。</p>
<p>对于用户程序打开的文件或设备，操作系统会从 3 开始分配文件描述符。每打开一个文件或 I&#x2F;O 资源，操作系统会返回一个新的文件描述符。</p>
<h3 id="文件描述符与文件操作"><a href="#文件描述符与文件操作" class="headerlink" title="文件描述符与文件操作"></a>文件描述符与文件操作</h3><p>文件描述符是进程与文件、套接字等 I&#x2F;O 资源进行交互的 <strong>接口</strong>。通过文件描述符，进程可以执行各种操作，如读取、写入、关闭等。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li><strong>打开文件</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure>

<p>这里，<code>open()</code> 系统调用返回一个文件描述符 <code>fd</code>，它代表了 <code>&quot;file.txt&quot;</code> 这个文件。</p>
<ul>
<li><strong>读写文件</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> bytes_read = read(fd, buffer, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><code>read()</code> 系统调用使用文件描述符 <code>fd</code> 来读取文件内容。</p>
<ul>
<li><strong>关闭文件</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<p><code>close()</code> 系统调用用来关闭文件描述符 <code>fd</code>，释放内核资源。</p>
<h3 id="文件描述符的底层实现"><a href="#文件描述符的底层实现" class="headerlink" title="文件描述符的底层实现"></a>文件描述符的底层实现</h3><p>操作系统内部使用文件描述符来管理文件。每个文件描述符对应一个 <strong>文件表项</strong>（file table entry），它包含了以下信息：</p>
<ul>
<li>文件的偏移量（即文件指针的位置）</li>
<li>文件的访问权限</li>
<li>当前打开的文件的状态（如是否已打开）</li>
</ul>
<p>这些信息存在于操作系统内核的内存中。当进程使用文件描述符进行操作时，内核会根据该描述符查找对应的文件表项，从而完成对文件的读写、关闭等操作。</p>
<h3 id="文件描述符的用途"><a href="#文件描述符的用途" class="headerlink" title="文件描述符的用途"></a>文件描述符的用途</h3><p>文件描述符不仅仅用于文件，还用于其他类型的 I&#x2F;O 资源，如：</p>
<ul>
<li><strong>网络套接字（Socket）</strong>：用于处理网络通信。</li>
<li><strong>管道（Pipe）</strong>：用于进程间通信（IPC）。</li>
<li><strong>设备文件</strong>：如 <code>/dev/null</code>、<code>/dev/sda</code> 等，表示硬件设备。</li>
</ul>
<p>因此，文件描述符是操作系统实现 I&#x2F;O 操作的一个 <strong>抽象接口</strong>，它使得程序可以通过统一的方式访问不同的资源。</p>
<h3 id="示例：标准输入输出的使用"><a href="#示例：标准输入输出的使用" class="headerlink" title="示例：标准输入输出的使用"></a>示例：标准输入输出的使用</h3><p>在 C 语言中，你可以通过文件描述符直接进行标准输入输出操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> bytes_read = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span>(buf));  <span class="comment">// 从标准输入读取数据，文件描述符 0 是标准输入</span></span><br><span class="line">    write(<span class="number">1</span>, buf, bytes_read);  <span class="comment">// 向标准输出写入数据，文件描述符 1 是标准输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>0</code> 和 <code>1</code> 就是标准输入和标准输出的文件描述符，<code>read()</code> 和 <code>write()</code> 系统调用通过这些文件描述符与 I&#x2F;O 设备交互。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>文件描述符</strong> 是操作系统分配给进程的整数，用于表示已打开的文件、套接字、管道等 I&#x2F;O 资源。</li>
<li>它是进程与外部资源进行交互的 <strong>抽象接口</strong>，允许操作系统统一管理所有类型的 I&#x2F;O 操作。</li>
<li>文件描述符通常从 3 开始，标准输入、标准输出、标准错误分别是 0、1、2。</li>
<li>通过文件描述符，程序可以执行如读取、写入、关闭等操作，而无需直接处理底层的设备细节。</li>
</ul>
<p>虽然文件描述符的概念抽象，但它是操作系统中 I&#x2F;O 操作的基础，理解它有助于更好地掌握系统资源的管理。</p>
<hr>
<h1 id="设备管理与I-O系统"><a href="#设备管理与I-O系统" class="headerlink" title="设备管理与I&#x2F;O系统"></a>设备管理与I&#x2F;O系统</h1><h2 id="设备管理的目标"><a href="#设备管理的目标" class="headerlink" title="设备管理的目标"></a>设备管理的目标</h2><p>操作系统中的设备管理负责协调各种<strong>输入输出设备</strong>的访问和调度，包括磁盘、键盘、显示器、网卡、打印机等。</p>
<p>主要目标包括：</p>
<ul>
<li><strong>统一接口</strong>：为应用程序屏蔽硬件差异</li>
<li><strong>资源共享</strong>：协调多个进程访问同一设备</li>
<li><strong>并发控制</strong>：避免冲突和竞争</li>
<li><strong>性能优化</strong>：提升设备利用率和响应速度</li>
</ul>
<hr>
<h2 id="设备的分类"><a href="#设备的分类" class="headerlink" title="设备的分类"></a>设备的分类</h2><p>按功能和控制方式，设备可以分为以下几类：</p>
<h3 id="按功能划分"><a href="#按功能划分" class="headerlink" title="按功能划分"></a>按功能划分</h3><ul>
<li><strong>块设备（Block Devices）</strong>：以固定大小块为单位读写，如硬盘、SSD、光驱</li>
<li><strong>字符设备（Character Devices）</strong>：按字节流方式读写，如串口、键盘、鼠标</li>
<li><strong>网络设备（Network Devices）</strong>：进行数据包发送和接收，如网卡</li>
</ul>
<h3 id="按访问方式划分"><a href="#按访问方式划分" class="headerlink" title="按访问方式划分"></a>按访问方式划分</h3><ul>
<li><strong>随机访问设备</strong>：如磁盘，支持跳转到任意位置读写</li>
<li><strong>顺序访问设备</strong>：如磁带，必须按顺序读取</li>
</ul>
<hr>
<h2 id="驱动程序的作用"><a href="#驱动程序的作用" class="headerlink" title="驱动程序的作用"></a>驱动程序的作用</h2><p>设备驱动程序是设备和操作系统之间的“翻译官”，将统一的系统调用接口转换成设备控制指令。</p>
<p>驱动程序通常以模块形式加载到内核中，具备以下特性：</p>
<ul>
<li>面向特定硬件编写，强依赖设备细节</li>
<li>提供初始化、读写、中断处理等功能</li>
<li>支持热插拔、错误恢复、功耗管理等高级功能</li>
</ul>
<p>现代操作系统使用 **设备树（Device Tree）**或 <strong>ACPI 表</strong>进行设备发现和初始化。</p>
<hr>
<h2 id="I-O-操作的基本流程"><a href="#I-O-操作的基本流程" class="headerlink" title="I&#x2F;O 操作的基本流程"></a>I&#x2F;O 操作的基本流程</h2><p>一次典型的 I&#x2F;O 操作大致流程如下：</p>
<ol>
<li>用户调用标准库函数（如 <code>read()</code>、<code>write()</code>）</li>
<li>操作系统发出系统调用，进入内核</li>
<li>驱动程序控制设备开始传输</li>
<li>设备完成操作后发送中断信号</li>
<li>操作系统唤醒等待进程，返回数据</li>
</ol>
<hr>
<h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I&#x2F;O 模型"></a>I&#x2F;O 模型</h2><p>操作系统提供多种 I&#x2F;O 模型，用于平衡“等待时间”和“并发能力”。</p>
<h3 id="阻塞-I-O"><a href="#阻塞-I-O" class="headerlink" title="阻塞 I&#x2F;O"></a>阻塞 I&#x2F;O</h3><p>调用方发出 I&#x2F;O 请求后，<strong>阻塞等待</strong>数据返回，适合简单场景，但性能不高。</p>
<h3 id="非阻塞-I-O"><a href="#非阻塞-I-O" class="headerlink" title="非阻塞 I&#x2F;O"></a>非阻塞 I&#x2F;O</h3><p>立即返回，如果没有数据可读，则返回错误码。适合轮询模型。</p>
<h3 id="多路复用-I-O（select-poll-epoll）"><a href="#多路复用-I-O（select-poll-epoll）" class="headerlink" title="多路复用 I&#x2F;O（select&#x2F;poll&#x2F;epoll）"></a>多路复用 I&#x2F;O（select&#x2F;poll&#x2F;epoll）</h3><p>单个线程监控多个 I&#x2F;O 事件，适合高并发网络服务器。</p>
<ul>
<li><code>select</code>：支持有限文件描述符，性能一般</li>
<li><code>poll</code>：不限数量，但每次都要遍历</li>
<li><code>epoll</code>：事件驱动机制，性能优越（Linux 特有）</li>
</ul>
<h3 id="异步-I-O（AIO）"><a href="#异步-I-O（AIO）" class="headerlink" title="异步 I&#x2F;O（AIO）"></a>异步 I&#x2F;O（AIO）</h3><p>I&#x2F;O 调用立即返回，操作系统<strong>后台完成数据传输</strong>后通知用户程序，真正意义上的“非阻塞”。</p>
<ul>
<li>实现复杂，但极大减少线程上下文切换</li>
<li>在高性能服务器和数据库中常见</li>
</ul>
<hr>
<h2 id="中断机制与-DMA"><a href="#中断机制与-DMA" class="headerlink" title="中断机制与 DMA"></a>中断机制与 DMA</h2><h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p>设备完成操作后，通过发送中断请求（IRQ）通知 CPU，无需程序主动等待。</p>
<ul>
<li><strong>硬件中断</strong>：设备主动发起</li>
<li><strong>软件中断</strong>：程序触发，如 <code>int 0x80</code> 系统调用</li>
</ul>
<p>中断处理程序运行在内核态，必须快速响应并尽快返回。</p>
<h3 id="DMA（Direct-Memory-Access）"><a href="#DMA（Direct-Memory-Access）" class="headerlink" title="DMA（Direct Memory Access）"></a>DMA（Direct Memory Access）</h3><p>DMA 控制器允许设备<strong>绕过 CPU 直接访问内存</strong>，极大提高 I&#x2F;O 效率。</p>
<ul>
<li>典型应用：磁盘读写、大规模数据传输</li>
<li>CPU 只需发出命令，数据搬运由 DMA 完成</li>
</ul>
<hr>
<h2 id="缓冲区与缓存机制"><a href="#缓冲区与缓存机制" class="headerlink" title="缓冲区与缓存机制"></a>缓冲区与缓存机制</h2><p>I&#x2F;O 操作通常通过缓冲区实现数据的<strong>批量传输</strong>，减少频繁调用和上下文切换：</p>
<ul>
<li><strong>用户缓冲区</strong>：由应用程序分配，如读取文件时的 buffer</li>
<li><strong>内核缓冲区</strong>：系统内部缓存区，如页缓存、IO 缓冲</li>
</ul>
<p>Linux 提供如下几种常见缓存机制：</p>
<ul>
<li><strong>页缓存（Page Cache）</strong>：文件内容缓存，提高读写性能</li>
<li><strong>目录项缓存（dentry cache）</strong>：目录路径缓存，提升文件系统效率</li>
<li><strong>inode 缓存</strong>：保存文件 inode 信息，避免重复读盘</li>
</ul>
<hr>
<h2 id="I-O-调度算法"><a href="#I-O-调度算法" class="headerlink" title="I&#x2F;O 调度算法"></a>I&#x2F;O 调度算法</h2><p>当多个进程同时请求磁盘 I&#x2F;O 时，操作系统通过调度算法优化执行顺序：</p>
<ul>
<li><strong>FCFS（先来先服务）</strong>：简单但效率低</li>
<li><strong>SSTF（最短寻道时间优先）</strong>：优先处理距离当前磁头最近的请求</li>
<li><strong>SCAN（电梯算法）</strong>：磁头像电梯一样来回移动处理请求</li>
<li><strong>CFQ（完全公平队列）</strong>：为每个进程分配时间片，保持公平性（Linux 默认）</li>
</ul>
<hr>
<h2 id="设备文件与-dev-目录"><a href="#设备文件与-dev-目录" class="headerlink" title="设备文件与 &#x2F;dev 目录"></a>设备文件与 &#x2F;dev 目录</h2><p>Linux 中设备被抽象为文件，统一存储在 <code>/dev</code> 目录中。</p>
<ul>
<li>每个设备文件对应一个驱动和设备实例</li>
<li>使用主设备号（major）标识驱动程序</li>
<li>使用次设备号（minor）标识设备编号</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda      <span class="comment"># 第一块磁盘</span></span><br><span class="line">/dev/tty0     <span class="comment"># 第一个终端</span></span><br><span class="line">/dev/null     <span class="comment"># 空设备，丢弃写入数据</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p><strong>零拷贝 <strong>指的是在数据传输过程中，尽量</strong>避免 CPU 进行多次内存拷贝</strong>操作，从而提升 I&#x2F;O 性能，降低 CPU 负载，尤其适用于高性能网络服务和大文件传输场景。</p>
<p>传统的数据传输方式在用户态和内核态之间涉及<strong>多次数据复制</strong>，而零拷贝通过各种机制尽量避免这些不必要的拷贝。</p>
<hr>
<h3 id="传统-I-O-的拷贝过程（以发送文件为例）"><a href="#传统-I-O-的拷贝过程（以发送文件为例）" class="headerlink" title="传统 I&#x2F;O 的拷贝过程（以发送文件为例）"></a>传统 I&#x2F;O 的拷贝过程（以发送文件为例）</h3><p>以一个应用程序发送文件数据到网络为例，传统流程大概如下：</p>
<ol>
<li>磁盘上的文件内容通过 DMA 拷贝到内核缓冲区（Page Cache）</li>
<li>操作系统通过 <code>read()</code> 将数据从内核缓冲区拷贝到用户缓冲区（用户态）</li>
<li>应用程序调用 <code>send()</code>，再把用户缓冲区数据拷贝回内核的 socket 缓冲区</li>
<li>最后，数据通过网卡 DMA 发送出去</li>
</ol>
<p>这整个过程涉及<strong>两次用户态和内核态之间的内存拷贝</strong>，非常耗费 CPU 和内存带宽。</p>
<hr>
<h3 id="零拷贝是怎么做的"><a href="#零拷贝是怎么做的" class="headerlink" title="零拷贝是怎么做的"></a>零拷贝是怎么做的</h3><p>为了优化这类过程，现代操作系统（尤其是 Linux）支持一系列“零拷贝”技术主要思想是<strong>消除用户态和内核态之间的数据拷贝</strong>，从本质上说，零拷贝的优化目标是：</p>
<ul>
<li><strong>避免用户态 <strong><strong>↔</strong></strong> 内核态的数据拷贝</strong></li>
<li><strong>利用 DMA</strong>（Direct Memory Access）进行磁盘或网卡直接读写</li>
<li><strong>重用页缓存</strong>或<strong>内存映射</strong>等机制，减少数据搬运</li>
</ul>
<p>常见方式有：</p>
<h4 id="sendfile-系统调用"><a href="#sendfile-系统调用" class="headerlink" title="sendfile() 系统调用"></a><code>sendfile()</code> 系统调用</h4><p>这是 Linux 最常用的零拷贝接口，专门用来将一个文件“直接发送”到网络套接字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendfile(out_fd, in_fd, <span class="literal">NULL</span>, len);</span><br></pre></td></tr></table></figure>

<ul>
<li>内核内部直接将磁盘数据从 Page Cache 映射到 socket 缓冲区</li>
<li>避免用户态中间缓冲，<strong>完全不经过用户空间</strong></li>
</ul>
<p>实现中仍可能使用 DMA 和 page remapping 等方式来减少复制次数。</p>
<h4 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap() + write()"></a><code>mmap()</code> + <code>write()</code></h4><ul>
<li>使用 <code>mmap()</code> 将文件直接映射到进程地址空间</li>
<li>不显式复制数据，直接通过地址映射访问数据</li>
<li>可用于共享内存或文件映射，也算是一种“用户空间零拷贝”</li>
</ul>
<p>不过这种方式仍可能涉及写入时的额外 copy，不如 <code>sendfile()</code> 更彻底。</p>
<h4 id="splice-tee-vmsplice"><a href="#splice-tee-vmsplice" class="headerlink" title="splice() &#x2F; tee() &#x2F; vmsplice()"></a><code>splice()</code> &#x2F; <code>tee()</code> &#x2F; <code>vmsplice()</code></h4><p>这是 Linux 提供的更底层的零拷贝接口，用于在文件描述符之间转移数据：</p>
<ul>
<li><code>splice()</code>：把数据从一个文件描述符“管道”到另一个，不经用户态</li>
<li><code>tee()</code>：复制管道内容，不拷贝数据</li>
<li><code>vmsplice()</code>：把用户缓冲区直接插入到管道中</li>
</ul>
<p>这类接口配合管道&#x2F;套接字使用，可以实现极高性能的数据搬运（比如视频转发服务器）。</p>
<hr>
<h1 id="系统启动流程与内核机制"><a href="#系统启动流程与内核机制" class="headerlink" title="系统启动流程与内核机制"></a>系统启动流程与内核机制</h1><h2 id="系统启动的整体流程概览"><a href="#系统启动的整体流程概览" class="headerlink" title="系统启动的整体流程概览"></a>系统启动的整体流程概览</h2><p>从按下电源按钮开始，到桌面或命令行界面出现，操作系统经历了以下关键阶段：</p>
<ol>
<li><strong>固件初始化（BIOS 或 UEFI）</strong></li>
<li><strong>引导加载器（Bootloader）启动</strong></li>
<li><strong>内核加载与初始化</strong></li>
<li><strong>用户空间初始化（init 系统）</strong></li>
<li><strong>系统服务启动，进入用户交互界面</strong></li>
</ol>
<hr>
<h2 id="固件初始化（BIOS-UEFI）"><a href="#固件初始化（BIOS-UEFI）" class="headerlink" title="固件初始化（BIOS &#x2F; UEFI）"></a>固件初始化（BIOS &#x2F; UEFI）</h2><p>当电源接通后，主板上的 BIOS（老式）或 UEFI（现代）固件首先运行。</p>
<ul>
<li>负责进行 <strong>POST（Power-On Self Test）</strong>，检查内存、CPU、硬盘等是否正常</li>
<li>枚举设备，构建硬件环境信息</li>
<li>查找并加载引导设备（硬盘、U 盘等）上的引导加载器程序</li>
</ul>
<p>UEFI 是 BIOS 的升级版，支持图形界面、GPT 分区、网络引导等高级功能。</p>
<hr>
<h2 id="引导加载器（Bootloader）"><a href="#引导加载器（Bootloader）" class="headerlink" title="引导加载器（Bootloader）"></a>引导加载器（Bootloader）</h2><p>引导加载器是磁盘上最先运行的操作系统组件，负责将内核加载到内存中，并交出控制权。</p>
<p>常见引导程序包括：</p>
<ul>
<li><strong>GRUB（GRand Unified Bootloader）</strong>：最常用的 Linux 启动器</li>
<li><strong>LILO</strong>：早期的引导程序，已逐步被淘汰</li>
<li><strong>Windows Boot Manager</strong>：Windows 系统的启动器</li>
</ul>
<p>GRUB 的典型工作流程：</p>
<ol>
<li>加载自身（位于磁盘 MBR 或 EFI 分区）</li>
<li>显示操作系统菜单（多系统引导）</li>
<li>加载内核镜像（如 <code>/boot/vmlinuz</code>）到内存</li>
<li>加载 initrd&#x2F;initramfs 初始内存盘</li>
<li>跳转到内核入口地址开始执行</li>
</ol>
<hr>
<h2 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h2><p>内核接手之后，开始执行一系列底层初始化动作：</p>
<ul>
<li>检测和初始化 CPU、内存、I&#x2F;O 设备</li>
<li>建立中断向量表、内核页表、内存管理结构</li>
<li>启动内核线程，如 <code>kthreadd</code>、<code>ksoftirqd</code>、<code>kworker</code> 等</li>
<li>挂载根文件系统（从 initramfs 解压或磁盘中挂载 <code>/</code>）</li>
<li>执行第一个用户态进程：<code>/sbin/init</code>（或 systemd）</li>
</ul>
<p>这一步之后，内核正式进入“运行态”，并开始管理整个系统。</p>
<hr>
<h2 id="用户空间初始化（init-进程）"><a href="#用户空间初始化（init-进程）" class="headerlink" title="用户空间初始化（init 进程）"></a>用户空间初始化（init 进程）</h2><p><code>init</code> 进程是用户空间的第一个进程，其 PID 恒为 1，是所有用户进程的祖先。</p>
<p>目前主流的 <code>init</code> 系统有：</p>
<ul>
<li><strong>System V init</strong>：早期采用，使用脚本启动服务，串行启动，效率不高</li>
<li><strong>Upstart</strong>：Ubuntu 曾用，事件驱动模型</li>
<li><strong>systemd</strong>：现代 Linux 系统主流，支持并行启动、服务依赖管理、日志记录（journald）等功能</li>
</ul>
<p>systemd 会根据配置文件：</p>
<ol>
<li>启动目标单元（target，如 <code>graphical.target</code>）</li>
<li>启动后台服务（如 network、dbus、sshd）</li>
<li>启动登录界面（TTY、GDM、LightDM 等）</li>
</ol>
<p>最终进入用户交互状态。</p>
<hr>
<h2 id="用户态与内核态切换"><a href="#用户态与内核态切换" class="headerlink" title="用户态与内核态切换"></a>用户态与内核态切换</h2><p>操作系统运行在两个权限级别：</p>
<ul>
<li><strong>用户态（User Mode）</strong>：应用程序运行的环境，权限受限</li>
<li><strong>内核态（Kernel Mode）</strong>：内核代码运行环境，权限最高</li>
</ul>
<p>从用户态进入内核态的三种方式：</p>
<ol>
<li><strong>系统调用（syscall）</strong>：如 <code>read()</code>、<code>fork()</code>，用户显式请求操作系统服务</li>
<li><strong>中断（interrupt）</strong>：如硬件设备完成任务后发出的信号</li>
<li><strong>异常（exception）</strong>：如除以 0、访问非法内存等</li>
</ol>
<p>内核态执行完毕后，必须安全返回用户态，恢复之前的上下文信息。</p>
<hr>
<h2 id="系统调用机制"><a href="#系统调用机制" class="headerlink" title="系统调用机制"></a>系统调用机制</h2><p>系统调用是用户程序访问操作系统核心服务的唯一合法入口。</p>
<p>流程如下：</p>
<ol>
<li>用户程序调用 C 库函数（如 <code>open()</code>）</li>
<li>C 库使用 <code>syscall</code> 指令切入内核态</li>
<li>内核根据调用号（Syscall Number）执行对应的内核服务</li>
<li>执行完毕后切回用户态，返回结果</li>
</ol>
<p>Linux 使用软中断（int 0x80）或 <code>sysenter/syscall</code> 指令进行系统调用，效率较高。</p>
<hr>
<h2 id="内核模块与热插拔机制"><a href="#内核模块与热插拔机制" class="headerlink" title="内核模块与热插拔机制"></a>内核模块与热插拔机制</h2><p>内核为提高灵活性，将部分功能设计成可加载模块（<code>.ko</code> 文件），如文件系统、设备驱动等。</p>
<ul>
<li>使用 <code>insmod</code> 加载模块，<code>rmmod</code> 卸载模块</li>
<li>使用 <code>modprobe</code> 管理依赖关系</li>
<li>使用 <code>lsmod</code> 查看当前已加载模块</li>
</ul>
<p>模块机制支持设备<strong>热插拔</strong>、内核调试和按需加载。</p>
<hr>
<h2 id="内核日志与调试"><a href="#内核日志与调试" class="headerlink" title="内核日志与调试"></a>内核日志与调试</h2><p>Linux 提供多种内核日志和调试工具：</p>
<ul>
<li><code>dmesg</code>：查看启动日志和驱动信息</li>
<li><code>/proc</code> 文件系统：以文件方式提供内核状态信息（如 <code>/proc/cpuinfo</code>）</li>
<li><code>strace</code>：跟踪进程的系统调用</li>
<li><code>perf</code>：分析性能瓶颈</li>
<li><code>gdb</code> + <code>qemu</code>：进行内核级调试</li>
</ul>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://lyi61pd.github.io">lyi61pd</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://lyi61pd.github.io/2025/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">https://lyi61pd.github.io/2025/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post-share"><div class="social-share" data-image="/blog_imgs/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/17/CVE-2021-3156/" title="CVE-2021-3156"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">CVE-2021-3156</div></div><div class="info-2"><div class="info-item-1">漏洞原理在sudo的parse_args()函数中，重写了argv，将命令行的参数存储到cmnd中(587-595行)，将参数中的字母数字_-$以外的字符，也就是元字符，前面加上反斜杠\来转义处理（590-591行） 123456789101112131415161718192021222324252627282930571     if (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123; 572         char **av, *cmnd = NULL; 573         int ac = 1; ... 581             cmnd = dst = reallocarray(NULL, cmnd_size, 2); ... 			// 将命令行的参数存储到dst,即cmnd中587             for (av = argv; *av != NULL; av++) &#123; 588                 for (src = *av; *src...</div></div></div></a><a class="pagination-related" href="/2025/04/22/Python/" title="Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Python</div></div><div class="info-2"><div class="info-item-1">引用与非引用类型Python中的引用类型与非引用类型在Python中，数据类型可以分为引用类型（可变类型）和非引用类型（不可变类型）。它们在内存中的存储方式和函数传参时的行为有明显的区别。 引用类型与非引用类型引用类型（可变类型）引用类型是指那些在内存中可以被修改的对象。常见的引用类型包括：  列表（List） 字典（Dict） 集合（Set）  这些类型的对象在创建后，其内容是可以修改的。对于这些类型的数据，当它们作为函数参数传递时，实际上传递的是对象的引用（即内存地址）。因此，在函数内对该对象进行修改时，原始对象的内容会发生变化。 示例： 123456def modify_list(my_list):    my_list.append(4)  # 修改传入的列表lst = [1, 2, 3]modify_list(lst)print(lst)  # 输出：[1, 2, 3,...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/blog_imgs/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">lyi61pd</div><div class="author-info-description">Im gonna be the best dragon</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lyi61pd"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">操作系统的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.</span> <span class="toc-text">什么是操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.</span> <span class="toc-text">操作系统的主要功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">进程管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.4.</span> <span class="toc-text">设备管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.5.</span> <span class="toc-text">用户接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-1"><span class="toc-number">2.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">什么是进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">进程与程序的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.3.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88Context-Switch%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">上下文切换（Context Switch）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.5.</span> <span class="toc-text">线程与进程的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.6.</span> <span class="toc-text">多进程与多线程的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.7.</span> <span class="toc-text">进程调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">进程间通信（IPC）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">2.9.</span> <span class="toc-text">同步与互斥</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89-1"><span class="toc-number">3.</span> <span class="toc-text">进程间通信（IPC）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IPC-%E7%9A%84%E5%85%B8%E5%9E%8B%E7%94%A8%E9%80%94"><span class="toc-number">3.1.</span> <span class="toc-text">IPC 的典型用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">常见的进程间通信方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%EF%BC%88Pipe%EF%BC%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">管道（Pipe）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">命名管道（FIFO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88Message-Queue%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">消息队列（Message Queue）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88Shared-Memory%EF%BC%89"><span class="toc-number">3.2.4.</span> <span class="toc-text">共享内存（Shared Memory）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89"><span class="toc-number">3.2.5.</span> <span class="toc-text">信号量（Semaphore）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%EF%BC%88Signal%EF%BC%89"><span class="toc-number">3.2.6.</span> <span class="toc-text">信号（Signal）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%88Socket%EF%BC%89"><span class="toc-number">3.2.7.</span> <span class="toc-text">套接字（Socket）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-IPC-%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">实际开发中如何选择 IPC 方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1"><span class="toc-number">4.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">内存管理的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">地址空间与地址类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%EF%BC%88%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%EF%BC%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">逻辑地址（虚拟地址）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">4.2.2.</span> <span class="toc-text">物理地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">4.2.3.</span> <span class="toc-text">地址空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%EF%BC%88Segmentation%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">分段（Segmentation）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%EF%BC%88Paging%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">分页（Paging）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">4.4.1.</span> <span class="toc-text">地址转换过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%88Virtual-Memory%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">虚拟内存（Virtual Memory）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FIFO%EF%BC%88%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%89"><span class="toc-number">4.6.1.</span> <span class="toc-text">FIFO（先进先出）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU%EF%BC%88%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">4.6.2.</span> <span class="toc-text">LRU（最近最少使用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clock%EF%BC%88%E6%97%B6%E9%92%9F%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">4.6.3.</span> <span class="toc-text">Clock（时钟算法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">4.7.</span> <span class="toc-text">内存分配策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E4%B8%8E%E5%BF%AB%E8%A1%A8%EF%BC%88TLB%EF%BC%89"><span class="toc-number">4.8.</span> <span class="toc-text">多级页表与快表（TLB）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E4%B8%8E%E5%85%B1%E4%BA%AB"><span class="toc-number">4.9.</span> <span class="toc-text">内存保护与共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E6%A1%88%E4%BE%8B%EF%BC%9ALinux-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">4.10.</span> <span class="toc-text">典型案例：Linux 内存结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-1"><span class="toc-number">5.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">文件系统的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">文件的逻辑结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87"><span class="toc-number">5.3.</span> <span class="toc-text">文件目录组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%B1%82%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.1.</span> <span class="toc-text">单层目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.2.</span> <span class="toc-text">二级目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%EF%BC%88%E7%8E%B0%E4%BB%A3%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%EF%BC%89"><span class="toc-number">5.3.3.</span> <span class="toc-text">树形目录结构（现代系统通用）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inode%EF%BC%88%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">inode（索引节点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">5.5.</span> <span class="toc-text">文件的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.6.</span> <span class="toc-text">磁盘空间的分配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">5.6.1.</span> <span class="toc-text">连续分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%88%86%E9%85%8D"><span class="toc-number">5.6.2.</span> <span class="toc-text">链式分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-number">5.6.3.</span> <span class="toc-text">索引分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.7.</span> <span class="toc-text">常见文件系统类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FAT%EF%BC%88File-Allocation-Table%EF%BC%89"><span class="toc-number">5.7.1.</span> <span class="toc-text">FAT（File Allocation Table）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NTFS%EF%BC%88Windows-%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="toc-number">5.7.2.</span> <span class="toc-text">NTFS（Windows 默认）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ext-%E7%B3%BB%E5%88%97%EF%BC%88Linux%EF%BC%89"><span class="toc-number">5.7.3.</span> <span class="toc-text">ext 系列（Linux）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XFS%E3%80%81ZFS%E3%80%81Btrfs-%E7%AD%89"><span class="toc-number">5.7.4.</span> <span class="toc-text">XFS、ZFS、Btrfs 等</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">5.8.</span> <span class="toc-text">缓存与写入机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">5.9.</span> <span class="toc-text">符号链接与硬链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%EF%BC%88Hard-Link%EF%BC%89"><span class="toc-number">5.9.1.</span> <span class="toc-text">硬链接（Hard Link）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%EF%BC%88Symbolic-Link%EF%BC%89"><span class="toc-number">5.9.2.</span> <span class="toc-text">符号链接（Symbolic Link）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="toc-number">5.10.</span> <span class="toc-text">文件系统的挂载与卸载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">5.11.</span> <span class="toc-text">文件描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.11.1.</span> <span class="toc-text">文件描述符的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">5.11.2.</span> <span class="toc-text">文件描述符的范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">5.11.3.</span> <span class="toc-text">文件描述符与文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.11.3.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.11.4.</span> <span class="toc-text">文件描述符的底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">5.11.5.</span> <span class="toc-text">文件描述符的用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.11.6.</span> <span class="toc-text">示例：标准输入输出的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.11.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E4%B8%8EI-O%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">设备管理与I&#x2F;O系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">6.1.</span> <span class="toc-text">设备管理的目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">设备的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%8A%9F%E8%83%BD%E5%88%92%E5%88%86"><span class="toc-number">6.2.1.</span> <span class="toc-text">按功能划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86"><span class="toc-number">6.2.2.</span> <span class="toc-text">按访问方式划分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">驱动程序的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-%E6%93%8D%E4%BD%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">6.4.</span> <span class="toc-text">I&#x2F;O 操作的基本流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.5.</span> <span class="toc-text">I&#x2F;O 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E-I-O"><span class="toc-number">6.5.1.</span> <span class="toc-text">阻塞 I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E-I-O"><span class="toc-number">6.5.2.</span> <span class="toc-text">非阻塞 I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-I-O%EF%BC%88select-poll-epoll%EF%BC%89"><span class="toc-number">6.5.3.</span> <span class="toc-text">多路复用 I&#x2F;O（select&#x2F;poll&#x2F;epoll）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-I-O%EF%BC%88AIO%EF%BC%89"><span class="toc-number">6.5.4.</span> <span class="toc-text">异步 I&#x2F;O（AIO）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E4%B8%8E-DMA"><span class="toc-number">6.6.</span> <span class="toc-text">中断机制与 DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">6.6.1.</span> <span class="toc-text">中断机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA%EF%BC%88Direct-Memory-Access%EF%BC%89"><span class="toc-number">6.6.2.</span> <span class="toc-text">DMA（Direct Memory Access）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">6.7.</span> <span class="toc-text">缓冲区与缓存机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">6.8.</span> <span class="toc-text">I&#x2F;O 调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E4%B8%8E-dev-%E7%9B%AE%E5%BD%95"><span class="toc-number">6.9.</span> <span class="toc-text">设备文件与 &#x2F;dev 目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">6.10.</span> <span class="toc-text">零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F-I-O-%E7%9A%84%E6%8B%B7%E8%B4%9D%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BB%A5%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">6.10.1.</span> <span class="toc-text">传统 I&#x2F;O 的拷贝过程（以发送文件为例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84"><span class="toc-number">6.10.2.</span> <span class="toc-text">零拷贝是怎么做的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sendfile-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">6.10.2.1.</span> <span class="toc-text">sendfile() 系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap-write"><span class="toc-number">6.10.2.2.</span> <span class="toc-text">mmap() + write()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#splice-tee-vmsplice"><span class="toc-number">6.10.2.3.</span> <span class="toc-text">splice() &#x2F; tee() &#x2F; vmsplice()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">系统启动流程与内核机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88"><span class="toc-number">7.1.</span> <span class="toc-text">系统启动的整体流程概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88BIOS-UEFI%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">固件初始化（BIOS &#x2F; UEFI）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88Bootloader%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">引导加载器（Bootloader）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">7.4.</span> <span class="toc-text">内核初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88init-%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">用户空间初始化（init 进程）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81%E5%88%87%E6%8D%A2"><span class="toc-number">7.6.</span> <span class="toc-text">用户态与内核态切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">7.7.</span> <span class="toc-text">系统调用机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%83%AD%E6%8F%92%E6%8B%94%E6%9C%BA%E5%88%B6"><span class="toc-number">7.8.</span> <span class="toc-text">内核模块与热插拔机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%97%A5%E5%BF%97%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-number">7.9.</span> <span class="toc-text">内核日志与调试</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/30/Sliver/" title="Sliver">Sliver</a><time datetime="2025-07-30T00:00:00.000Z" title="Created 2025-07-30 00:00:00">2025-07-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/07/%E6%B1%87%E7%BC%96/" title="汇编">汇编</a><time datetime="2025-07-07T00:00:00.000Z" title="Created 2025-07-07 00:00:00">2025-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/30/Git/" title="Git">Git</a><time datetime="2025-06-30T00:00:00.000Z" title="Created 2025-06-30 00:00:00">2025-06-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/Python/" title="Python">Python</a><time datetime="2025-04-22T00:00:00.000Z" title="Created 2025-04-22 00:00:00">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/17/CVE-2021-3156/" title="CVE-2021-3156">CVE-2021-3156</a><time datetime="2025-04-17T00:00:00.000Z" title="Created 2025-04-17 00:00:00">2025-04-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/blog_imgs/banner.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By lyi61pd</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>